<?xml version="1.0" encoding="UTF-8"?><database name="test" schema="public" type="PostgreSQL - 15.3 (Debian 15.3-1.pgdg120+1)">
   <tables>
      <table name="pg_all_foreign_keys" numRows="0" remarks="" schema="public" type="VIEW" viewSql=" SELECT n1.nspname AS fk_schema_name,&#10;    c1.relname AS fk_table_name,&#10;    k1.conname AS fk_constraint_name,&#10;    c1.oid AS fk_table_oid,&#10;    _pg_sv_column_array(k1.conrelid, k1.conkey) AS fk_columns,&#10;    n2.nspname AS pk_schema_name,&#10;    c2.relname AS pk_table_name,&#10;    k2.conname AS pk_constraint_name,&#10;    c2.oid AS pk_table_oid,&#10;    ci.relname AS pk_index_name,&#10;    _pg_sv_column_array(k1.confrelid, k1.confkey) AS pk_columns,&#10;        CASE k1.confmatchtype&#10;            WHEN 'f'::&quot;char&quot; THEN 'FULL'::text&#10;            WHEN 'p'::&quot;char&quot; THEN 'PARTIAL'::text&#10;            WHEN 'u'::&quot;char&quot; THEN 'NONE'::text&#10;            ELSE NULL::text&#10;        END AS match_type,&#10;        CASE k1.confdeltype&#10;            WHEN 'a'::&quot;char&quot; THEN 'NO ACTION'::text&#10;            WHEN 'c'::&quot;char&quot; THEN 'CASCADE'::text&#10;            WHEN 'd'::&quot;char&quot; THEN 'SET DEFAULT'::text&#10;            WHEN 'n'::&quot;char&quot; THEN 'SET NULL'::text&#10;            WHEN 'r'::&quot;char&quot; THEN 'RESTRICT'::text&#10;            ELSE NULL::text&#10;        END AS on_delete,&#10;        CASE k1.confupdtype&#10;            WHEN 'a'::&quot;char&quot; THEN 'NO ACTION'::text&#10;            WHEN 'c'::&quot;char&quot; THEN 'CASCADE'::text&#10;            WHEN 'd'::&quot;char&quot; THEN 'SET DEFAULT'::text&#10;            WHEN 'n'::&quot;char&quot; THEN 'SET NULL'::text&#10;            WHEN 'r'::&quot;char&quot; THEN 'RESTRICT'::text&#10;            ELSE NULL::text&#10;        END AS on_update,&#10;    k1.condeferrable AS is_deferrable,&#10;    k1.condeferred AS is_deferred&#10;   FROM ((((((((pg_constraint k1&#10;     JOIN pg_namespace n1 ON ((n1.oid = k1.connamespace)))&#10;     JOIN pg_class c1 ON ((c1.oid = k1.conrelid)))&#10;     JOIN pg_class c2 ON ((c2.oid = k1.confrelid)))&#10;     JOIN pg_namespace n2 ON ((n2.oid = c2.relnamespace)))&#10;     JOIN pg_depend d ON (((d.classid = ('pg_constraint'::regclass)::oid) AND (d.objid = k1.oid) AND (d.objsubid = 0) AND (d.deptype = 'n'::&quot;char&quot;) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.refobjsubid = 0))))&#10;     JOIN pg_class ci ON (((ci.oid = d.refobjid) AND (ci.relkind = 'i'::&quot;char&quot;))))&#10;     LEFT JOIN pg_depend d2 ON (((d2.classid = ('pg_class'::regclass)::oid) AND (d2.objid = ci.oid) AND (d2.objsubid = 0) AND (d2.deptype = 'i'::&quot;char&quot;) AND (d2.refclassid = ('pg_constraint'::regclass)::oid) AND (d2.refobjsubid = 0))))&#10;     LEFT JOIN pg_constraint k2 ON (((k2.oid = d2.refobjid) AND (k2.contype = ANY (ARRAY['p'::&quot;char&quot;, 'u'::&quot;char&quot;])))))&#10;  WHERE ((k1.conrelid &lt;&gt; (0)::oid) AND (k1.confrelid &lt;&gt; (0)::oid) AND (k1.contype = 'f'::&quot;char&quot;) AND _pg_sv_table_accessible(n1.oid, c1.oid));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="fk_schema_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="fk_table_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="fk_constraint_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="fk_table_oid" nullable="true" remarks="" size="10" type="oid" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="fk_columns" nullable="true" remarks="" size="2147483647" type="_name" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="pk_schema_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="pk_table_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="pk_constraint_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="pk_table_oid" nullable="true" remarks="" size="10" type="oid" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="pk_index_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="pk_columns" nullable="true" remarks="" size="2147483647" type="_name" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="match_type" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="on_delete" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="on_update" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="is_deferrable" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="is_deferred" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
      </table>
      <table name="TABLE1" numRows="5" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="m" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="n" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="o" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <primaryKey column="m" sequenceNumberInPK="1"/>
         <index name="TABLE1_pkey" unique="true">
            <column ascending="true" name="m"/>
         </index>
      </table>
      <table name="TABLE2" numRows="3" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="m" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="n" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="o" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <primaryKey column="m" sequenceNumberInPK="1"/>
         <index name="TABLE2_pkey" unique="true">
            <column ascending="true" name="m"/>
         </index>
      </table>
      <table name="TABLE3" numRows="4" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="m" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <primaryKey column="m" sequenceNumberInPK="1"/>
         <index name="TABLE3_pkey" unique="true">
            <column ascending="true" name="m"/>
         </index>
      </table>
      <table name="tap_funky" numRows="0" remarks="" schema="public" type="VIEW" viewSql=" SELECT p.oid,&#10;    n.nspname AS schema,&#10;    p.proname AS name,&#10;    pg_get_userbyid(p.proowner) AS owner,&#10;    array_to_string((p.proargtypes)::regtype[], ','::text) AS args,&#10;    (&#10;        CASE p.proretset&#10;            WHEN true THEN 'setof '::text&#10;            ELSE ''::text&#10;        END || (p.prorettype)::regtype) AS returns,&#10;    p.prolang AS langoid,&#10;    p.proisstrict AS is_strict,&#10;    _prokind(p.oid) AS kind,&#10;    p.prosecdef AS is_definer,&#10;    p.proretset AS returns_set,&#10;    (p.provolatile)::character(1) AS volatility,&#10;    pg_function_is_visible(p.oid) AS is_visible&#10;   FROM (pg_proc p&#10;     JOIN pg_namespace n ON ((p.pronamespace = n.oid)));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="oid" nullable="true" remarks="" size="10" type="oid" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="schema" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="owner" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="args" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="returns" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="langoid" nullable="true" remarks="" size="10" type="oid" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="is_strict" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="kind" nullable="true" remarks="" size="1" type="char" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="is_definer" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="returns_set" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="volatility" nullable="true" remarks="" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="is_visible" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
      </table>
   </tables>
   <routines>
      <routine dataAccess="MODIFIES" deterministic="false" name="_add(text, integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _add($1, $2, '')]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_add(text, integer, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    EXECUTE 'INSERT INTO __tcache__ (label, value, note) values (' ||
    quote_literal($1) || ', ' || $2 || ', ' || quote_literal(COALESCE($3, '')) || ')';
    RETURN $2;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_alike(boolean, anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    result ALIAS FOR $1;
    got    ALIAS FOR $2;
    rx     ALIAS FOR $3;
    descr  ALIAS FOR $4;
    output TEXT;
BEGIN
    output := ok( result, descr );
    RETURN output || CASE result WHEN TRUE THEN '' ELSE E'\n' || diag(
           '                  ' || COALESCE( quote_literal(got), 'NULL' ) ||
       E'\n   doesn''t match: ' || COALESCE( quote_literal(rx), 'NULL' )
    ) END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_ancestor_of(name, name, integer)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[WITH RECURSIVE inheritance_chain AS (
        -- select the ancestor tuple
        SELECT i.inhrelid AS descendent_id, 1 AS inheritance_level
          FROM pg_catalog.pg_inherits i
        WHERE i.inhparent = (
            SELECT c1.oid
              FROM pg_catalog.pg_class c1
              JOIN pg_catalog.pg_namespace n1
                ON c1.relnamespace = n1.oid
             WHERE c1.relname = $1
               AND pg_catalog.pg_table_is_visible( c1.oid )
        )
        UNION
        -- select the descendents
        SELECT i.inhrelid AS descendent_id,
               p.inheritance_level + 1 AS inheritance_level
          FROM pg_catalog.pg_inherits i
          JOIN inheritance_chain p
            ON p.descendent_id = i.inhparent
         WHERE i.inhrelid = (
            SELECT c1.oid
              FROM pg_catalog.pg_class c1
              JOIN pg_catalog.pg_namespace n1
                ON c1.relnamespace = n1.oid
             WHERE c1.relname = $2
               AND pg_catalog.pg_table_is_visible( c1.oid )
        )
    )
    SELECT EXISTS(
        SELECT true
          FROM inheritance_chain
         WHERE inheritance_level = COALESCE($3, inheritance_level)
           AND descendent_id = (
                SELECT c1.oid
                  FROM pg_catalog.pg_class c1
                  JOIN pg_catalog.pg_namespace n1
                    ON c1.relnamespace = n1.oid
                 WHERE c1.relname = $2
                   AND pg_catalog.pg_table_is_visible( c1.oid )
        )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_ancestor_of(name, name, name, name, integer)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[WITH RECURSIVE inheritance_chain AS (
        -- select the ancestor tuple
        SELECT i.inhrelid AS descendent_id, 1 AS inheritance_level
          FROM pg_catalog.pg_inherits i
        WHERE i.inhparent = (
            SELECT c1.oid
              FROM pg_catalog.pg_class c1
              JOIN pg_catalog.pg_namespace n1
                ON c1.relnamespace = n1.oid
             WHERE c1.relname = $2
               AND n1.nspname = $1
        )
        UNION
        -- select the descendents
        SELECT i.inhrelid AS descendent_id,
               p.inheritance_level + 1 AS inheritance_level
          FROM pg_catalog.pg_inherits i
          JOIN inheritance_chain p
            ON p.descendent_id = i.inhparent
         WHERE i.inhrelid = (
            SELECT c1.oid
              FROM pg_catalog.pg_class c1
              JOIN pg_catalog.pg_namespace n1
                ON c1.relnamespace = n1.oid
             WHERE c1.relname = $4
               AND n1.nspname = $3
        )
    )
    SELECT EXISTS(
        SELECT true
          FROM inheritance_chain
         WHERE inheritance_level = COALESCE($5, inheritance_level)
           AND descendent_id = (
                SELECT c1.oid
                  FROM pg_catalog.pg_class c1
                  JOIN pg_catalog.pg_namespace n1
                    ON c1.relnamespace = n1.oid
                 WHERE c1.relname = $4
                   AND n1.nspname = $3
        )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_are(text, name[], name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    what    ALIAS FOR $1;
    extras  ALIAS FOR $2;
    missing ALIAS FOR $3;
    descr   ALIAS FOR $4;
    msg     TEXT    := '';
    res     BOOLEAN := TRUE;
BEGIN
    IF extras[1] IS NOT NULL THEN
        res = FALSE;
        msg := E'\n' || diag(
            '    Extra ' || what || E':\n        '
            ||  _ident_array_to_sorted_string( extras, E'\n        ' )
        );
    END IF;
    IF missing[1] IS NOT NULL THEN
        res = FALSE;
        msg := msg || E'\n' || diag(
            '    Missing ' || what || E':\n        '
            ||  _ident_array_to_sorted_string( missing, E'\n        ' )
        );
    END IF;

    RETURN ok(res, descr) || msg;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_areni(text, text[], text[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    what    ALIAS FOR $1;
    extras  ALIAS FOR $2;
    missing ALIAS FOR $3;
    descr   ALIAS FOR $4;
    msg     TEXT    := '';
    res     BOOLEAN := TRUE;
BEGIN
    IF extras[1] IS NOT NULL THEN
        res = FALSE;
        msg := E'\n' || diag(
            '    Extra ' || what || E':\n        '
            ||  _array_to_sorted_string( extras, E'\n        ' )
        );
    END IF;
    IF missing[1] IS NOT NULL THEN
        res = FALSE;
        msg := msg || E'\n' || diag(
            '    Missing ' || what || E':\n        '
            ||  _array_to_sorted_string( missing, E'\n        ' )
        );
    END IF;

    RETURN ok(res, descr) || msg;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_array_to_sorted_string(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT array_to_string(ARRAY(
        SELECT $1[i]
          FROM generate_series(1, array_upper($1, 1)) s(i)
         ORDER BY $1[i]
    ), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_assets_are(text, text[], text[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _areni(
        $1,
        ARRAY(
            SELECT UPPER($2[i]) AS thing
              FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
             ORDER BY thing
        ),
        ARRAY(
            SELECT $3[i] AS thing
              FROM generate_series(1, array_upper($3, 1)) s(i)
            EXCEPT
            SELECT UPPER($2[i])
              FROM generate_series(1, array_upper($2, 1)) s(i)
             ORDER BY thing
        ),
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cast_exists(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
       SELECT TRUE
         FROM pg_catalog.pg_cast c
        WHERE _cmp_types(castsource, $1)
          AND _cmp_types(casttarget, $2)
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cast_exists(name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
       SELECT TRUE
         FROM pg_catalog.pg_cast c
         JOIN pg_catalog.pg_proc p ON c.castfunc = p.oid
        WHERE _cmp_types(castsource, $1)
          AND _cmp_types(casttarget, $2)
          AND p.proname   = $3
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cast_exists(name, name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
       SELECT TRUE
         FROM pg_catalog.pg_cast c
         JOIN pg_catalog.pg_proc p ON c.castfunc = p.oid
         JOIN pg_catalog.pg_namespace n ON p.pronamespace = n.oid
        WHERE _cmp_types(castsource, $1)
          AND _cmp_types(casttarget, $2)
          AND n.nspname   = $3
          AND p.proname   = $4
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cdi(name, name, anyelement)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_default_is(
        $1, $2, $3,
        'Column ' || quote_ident($1) || '.' || quote_ident($2) || ' should default to '
        || COALESCE( quote_literal($3), 'NULL')
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cdi(name, name, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF NOT _cexists( $1, $2 ) THEN
        RETURN fail( $4 ) || E'\n'
            || diag ('    Column ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist' );
    END IF;

    IF NOT _has_def( $1, $2 ) THEN
        RETURN fail( $4 ) || E'\n'
            || diag ('    Column ' || quote_ident($1) || '.' || quote_ident($2) || ' has no default' );
    END IF;

    RETURN _def_is(
        pg_catalog.pg_get_expr(d.adbin, d.adrelid),
        pg_catalog.format_type(a.atttypid, a.atttypmod),
        $3, $4
    )
      FROM pg_catalog.pg_class c, pg_catalog.pg_attribute a, pg_catalog.pg_attrdef d
     WHERE c.oid = a.attrelid
       AND pg_table_is_visible(c.oid)
       AND a.atthasdef
       AND a.attrelid = d.adrelid
       AND a.attnum = d.adnum
       AND c.relname = $1
       AND a.attnum > 0
       AND NOT a.attisdropped
       AND a.attname = $2;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cdi(name, name, name, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF NOT _cexists( $1, $2, $3 ) THEN
        RETURN fail( $5 ) || E'\n'
            || diag ('    Column ' || quote_ident($1) || '.' || quote_ident($2) || '.' || quote_ident($3) || ' does not exist' );
    END IF;

    IF NOT _has_def( $1, $2, $3 ) THEN
        RETURN fail( $5 ) || E'\n'
            || diag ('    Column ' || quote_ident($1) || '.' || quote_ident($2) || '.' || quote_ident($3) || ' has no default' );
    END IF;

    RETURN _def_is(
        pg_catalog.pg_get_expr(d.adbin, d.adrelid),
        pg_catalog.format_type(a.atttypid, a.atttypmod),
        $4, $5
    )
      FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c, pg_catalog.pg_attribute a,
           pg_catalog.pg_attrdef d
     WHERE n.oid = c.relnamespace
       AND c.oid = a.attrelid
       AND a.atthasdef
       AND a.attrelid = d.adrelid
       AND a.attnum = d.adnum
       AND n.nspname = $1
       AND c.relname = $2
       AND a.attnum > 0
       AND NOT a.attisdropped
       AND a.attname = $3;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cexists(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_class c
          JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
         WHERE c.relname = $1
           AND pg_catalog.pg_table_is_visible(c.oid)
           AND a.attnum > 0
           AND NOT a.attisdropped
           AND a.attname = $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cexists(name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_namespace n
          JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
          JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
         WHERE n.nspname = $1
           AND c.relname = $2
           AND a.attnum > 0
           AND NOT a.attisdropped
           AND a.attname = $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_ckeys(name, character)" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _keys($1, $2) LIMIT 1;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_ckeys(name, name, character)" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _keys($1, $2, $3) LIMIT 1;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cleanup()" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[DROP SEQUENCE __tresults___numb_seq;
    DROP TABLE __tcache__;
    DROP SEQUENCE __tcache___id_seq;
    SELECT TRUE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_cmp_types(oid, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    dtype TEXT := pg_catalog.format_type($1, NULL);
BEGIN
    RETURN dtype = _quote_ident_like($2, dtype);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_col_is_null(name, name, name, text, boolean)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    qcol CONSTANT text := quote_ident($1) || '.' || quote_ident($2) || '.' || quote_ident($3);
    c_desc CONSTANT text := coalesce(
        $4,
        'Column ' || qcol || ' should '
            || CASE WHEN $5 THEN 'be NOT' ELSE 'allow' END || ' NULL'
    );
BEGIN
    IF NOT _cexists( $1, $2, $3 ) THEN
        RETURN fail( c_desc ) || E'\n'
            || diag ('    Column ' || qcol || ' does not exist' );
    END IF;
    RETURN ok(
        EXISTS(
            SELECT true
              FROM pg_catalog.pg_namespace n
              JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
              JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
             WHERE n.nspname = $1
               AND c.relname = $2
               AND a.attnum  > 0
               AND NOT a.attisdropped
               AND a.attname    = $3
               AND a.attnotnull = $5
        ), c_desc
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_col_is_null(name, name, text, boolean)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    qcol CONSTANT text := quote_ident($1) || '.' || quote_ident($2);
    c_desc CONSTANT text := coalesce(
        $3,
        'Column ' || qcol || ' should '
            || CASE WHEN $4 THEN 'be NOT' ELSE 'allow' END || ' NULL'
    );
BEGIN
    IF NOT _cexists( $1, $2 ) THEN
        RETURN fail( c_desc ) || E'\n'
            || diag ('    Column ' || qcol || ' does not exist' );
    END IF;
    RETURN ok(
        EXISTS(
            SELECT true
              FROM pg_catalog.pg_class c
              JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
             WHERE pg_catalog.pg_table_is_visible(c.oid)
               AND c.relname = $1
               AND a.attnum > 0
               AND NOT a.attisdropped
               AND a.attname    = $2
               AND a.attnotnull = $4
        ), c_desc
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_constraint(name, character, name[], text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    akey NAME[];
    keys TEXT[] := '{}';
    have TEXT;
BEGIN
    FOR akey IN SELECT * FROM _keys($1, $2) LOOP
        IF akey = $3 THEN RETURN pass($4); END IF;
        keys = keys || akey::text;
    END LOOP;
    IF array_upper(keys, 0) = 1 THEN
        have := 'No ' || $5 || ' constraints';
    ELSE
        have := array_to_string(keys, E'\n              ');
    END IF;

    RETURN fail($4) || E'\n' || diag(
             '        have: ' || have
       || E'\n        want: ' || CASE WHEN $3 IS NULL THEN 'NULL' ELSE $3::text END
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_constraint(name, name, character, name[], text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    akey NAME[];
    keys TEXT[] := '{}';
    have TEXT;
BEGIN
    FOR akey IN SELECT * FROM _keys($1, $2, $3) LOOP
        IF akey = $4 THEN RETURN pass($5); END IF;
        keys = keys || akey::text;
    END LOOP;
    IF array_upper(keys, 0) = 1 THEN
        have := 'No ' || $6 || ' constraints';
    ELSE
        have := array_to_string(keys, E'\n              ');
    END IF;

    RETURN fail($5) || E'\n' || diag(
             '        have: ' || have
       || E'\n        want: ' || CASE WHEN $4 IS NULL THEN 'NULL' ELSE $4::text END
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_contract_on(text)" returnType="&quot;char&quot;" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE substring(LOWER($1) FROM 1 FOR 1)
          WHEN 's' THEN '1'::"char"
          WHEN 'u' THEN '2'::"char"
          WHEN 'i' THEN '3'::"char"
          WHEN 'd' THEN '4'::"char"
          ELSE          '0'::"char" END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_currtest()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    RETURN currval('__tresults___numb_seq');
EXCEPTION
    WHEN object_not_in_prerequisite_state THEN RETURN 0;
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_db_privs()" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    pgversion INTEGER := pg_version_num();
BEGIN
    IF pgversion < 80200 THEN
        RETURN ARRAY['CREATE', 'TEMPORARY'];
    ELSE
        RETURN ARRAY['CREATE', 'CONNECT', 'TEMPORARY'];
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_def_is(text, text, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    thing text;
BEGIN
    -- Function, cast, or special SQL syntax.
    IF $1 ~ '^[^'']+[(]' OR $1 ~ '[)]::[^'']+$' OR $1 = ANY('{CURRENT_CATALOG,CURRENT_ROLE,CURRENT_SCHEMA,CURRENT_USER,SESSION_USER,USER,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,LOCALTIME,LOCALTIMESTAMP}') THEN
        RETURN is( $1, $3, $4 );
    END IF;

    EXECUTE 'SELECT is('
             || COALESCE($1, 'NULL' || '::' || $2) || '::' || $2 || ', '
             || COALESCE(quote_literal($3), 'NULL') || '::' || $2 || ', '
             || COALESCE(quote_literal($4), 'NULL')
    || ')' INTO thing;
    RETURN thing;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_definer(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_definer FROM tap_funky WHERE name = $1 AND is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_definer(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_definer FROM tap_funky WHERE schema = $1 AND name = $2]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_definer(name, name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_definer
      FROM tap_funky
     WHERE schema = $1
       AND name   = $2
       AND args   = array_to_string($3, ',')]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_definer(name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_definer
      FROM tap_funky
     WHERE name = $1
       AND args = array_to_string($2, ',')
       AND is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_dexists(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
       SELECT true
         FROM pg_catalog.pg_type t
        WHERE t.typname = $1
          AND pg_catalog.pg_type_is_visible(t.oid)
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_dexists(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
       SELECT true
         FROM pg_catalog.pg_namespace n
         JOIN pg_catalog.pg_type t on n.oid = t.typnamespace
        WHERE n.nspname = $1
          AND t.typname = $2
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_do_ne(text, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have    ALIAS FOR $1;
    want    ALIAS FOR $2;
    extras  TEXT[]  := '{}';
    missing TEXT[]  := '{}';
    res     BOOLEAN := TRUE;
    msg     TEXT    := '';
BEGIN
    BEGIN
        -- Find extra records.
        EXECUTE 'SELECT EXISTS ( '
             || '( SELECT * FROM ' || have || ' EXCEPT ' || $4
             || '  SELECT * FROM ' || want
             || ' ) UNION ( '
             || '  SELECT * FROM ' || want || ' EXCEPT ' || $4
             || '  SELECT * FROM ' || have
             || ' ) LIMIT 1 )' INTO res;

        -- Drop the temporary tables.
        EXECUTE 'DROP TABLE ' || have;
        EXECUTE 'DROP TABLE ' || want;
    EXCEPTION WHEN syntax_error OR datatype_mismatch THEN
        msg := E'\n' || diag(
            E'    Columns differ between queries:\n'
            || '        have: (' || _temptypes(have) || E')\n'
            || '        want: (' || _temptypes(want) || ')'
        );
        EXECUTE 'DROP TABLE ' || have;
        EXECUTE 'DROP TABLE ' || want;
        RETURN ok(FALSE, $3) || msg;
    END;

    -- Return the value from the query.
    RETURN ok(res, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_docomp(text, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have    ALIAS FOR $1;
    want    ALIAS FOR $2;
    extras  TEXT[]  := '{}';
    missing TEXT[]  := '{}';
    res     BOOLEAN := TRUE;
    msg     TEXT    := '';
    rec     RECORD;
BEGIN
    BEGIN
        -- Find extra records.
        FOR rec in EXECUTE 'SELECT * FROM ' || have || ' EXCEPT ' || $4
                        || 'SELECT * FROM ' || want LOOP
            extras := extras || rec::text;
        END LOOP;

        -- Find missing records.
        FOR rec in EXECUTE 'SELECT * FROM ' || want || ' EXCEPT ' || $4
                        || 'SELECT * FROM ' || have LOOP
            missing := missing || rec::text;
        END LOOP;

        -- Drop the temporary tables.
        EXECUTE 'DROP TABLE ' || have;
        EXECUTE 'DROP TABLE ' || want;
    EXCEPTION WHEN syntax_error OR datatype_mismatch THEN
        msg := E'\n' || diag(
            E'    Columns differ between queries:\n'
            || '        have: (' || _temptypes(have) || E')\n'
            || '        want: (' || _temptypes(want) || ')'
        );
        EXECUTE 'DROP TABLE ' || have;
        EXECUTE 'DROP TABLE ' || want;
        RETURN ok(FALSE, $3) || msg;
    END;

    -- What extra records do we have?
    IF extras[1] IS NOT NULL THEN
        res := FALSE;
        msg := E'\n' || diag(
            E'    Extra records:\n        '
            ||  array_to_string( extras, E'\n        ' )
        );
    END IF;

    -- What missing records do we have?
    IF missing[1] IS NOT NULL THEN
        res := FALSE;
        msg := msg || E'\n' || diag(
            E'    Missing records:\n        '
            ||  array_to_string( missing, E'\n        ' )
        );
    END IF;

    RETURN ok(res, $3) || msg;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_error_diag(text, text, text, text, text, text, text, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT COALESCE(
               COALESCE( NULLIF($1, '') || ': ', '' ) || COALESCE( NULLIF($2, ''), '' ),
               'NO ERROR FOUND'
           )
        || COALESCE(E'\n        DETAIL:     ' || nullif($3, ''), '')
        || COALESCE(E'\n        HINT:       ' || nullif($4, ''), '')
        || COALESCE(E'\n        SCHEMA:     ' || nullif($6, ''), '')
        || COALESCE(E'\n        TABLE:      ' || nullif($7, ''), '')
        || COALESCE(E'\n        COLUMN:     ' || nullif($8, ''), '')
        || COALESCE(E'\n        CONSTRAINT: ' || nullif($9, ''), '')
        || COALESCE(E'\n        TYPE:       ' || nullif($10, ''), '')
        -- We need to manually indent all the context lines
        || COALESCE(E'\n        CONTEXT:\n'
               || regexp_replace(NULLIF( $5, ''), '^', '            ', 'gn'
           ), '');]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_expand_context(character)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE $1
          WHEN 'i' THEN 'implicit'
          WHEN 'a' THEN 'assignment'
          WHEN 'e' THEN 'explicit'
          ELSE          'unknown' END]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_expand_on(character)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE $1
          WHEN '1' THEN 'SELECT'
          WHEN '2' THEN 'UPDATE'
          WHEN '3' THEN 'INSERT'
          WHEN '4' THEN 'DELETE'
          ELSE          'UNKNOWN' END]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_expand_vol(character)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE $1
          WHEN 'i' THEN 'IMMUTABLE'
          WHEN 's' THEN 'STABLE'
          WHEN 'v' THEN 'VOLATILE'
          ELSE          'UNKNOWN' END]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_ext_exists(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
        SELECT TRUE
          FROM pg_catalog.pg_extension ex
         WHERE ex.extname = $1
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_ext_exists(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
        SELECT TRUE
          FROM pg_catalog.pg_extension ex
          JOIN pg_catalog.pg_namespace n ON ex.extnamespace = n.oid
         WHERE n.nspname  = $1
           AND ex.extname = $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_extensions()" returnType="SETOF name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT extname FROM pg_catalog.pg_extension]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_extensions(name)" returnType="SETOF name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT e.extname
      FROM pg_catalog.pg_namespace n
      JOIN pg_catalog.pg_extension e ON n.oid = e.extnamespace
     WHERE n.nspname = $1]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_extras(character, name, name[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _extras(ARRAY[$1], $2, $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_extras(character, name[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _extras(ARRAY[$1], $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_extras(character[], name, name[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT c.relname
          FROM pg_catalog.pg_namespace n
          JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
         WHERE c.relkind = ANY($1)
           AND n.nspname = $2
           AND c.relname NOT IN('pg_all_foreign_keys', 'tap_funky', '__tresults___numb_seq', '__tcache___id_seq')
        EXCEPT
        SELECT $3[i]
          FROM generate_series(1, array_upper($3, 1)) s(i)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="character[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_extras(character[], name[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT c.relname
          FROM pg_catalog.pg_namespace n
          JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
         WHERE pg_catalog.pg_table_is_visible(c.oid)
           AND n.nspname <> 'pg_catalog'
           AND c.relkind = ANY($1)
           AND c.relname NOT IN ('__tcache__', 'pg_all_foreign_keys', 'tap_funky', '__tresults___numb_seq', '__tcache___id_seq')
        EXCEPT
        SELECT $2[i]
          FROM generate_series(1, array_upper($2, 1)) s(i)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="character[]"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_finish(integer, integer, integer, boolean DEFAULT NULL::boolean)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    curr_test ALIAS FOR $1;
    exp_tests INTEGER := $2;
    num_faild ALIAS FOR $3;
    plural    CHAR;
    raise_ex  ALIAS FOR $4;
BEGIN
    plural    := CASE exp_tests WHEN 1 THEN '' ELSE 's' END;

    IF curr_test IS NULL THEN
        RAISE EXCEPTION '# No tests run!';
    END IF;

    IF exp_tests = 0 OR exp_tests IS NULL THEN
         -- No plan. Output one now.
        exp_tests = curr_test;
        RETURN NEXT '1..' || exp_tests;
    END IF;

    IF curr_test <> exp_tests THEN
        RETURN NEXT diag(
            'Looks like you planned ' || exp_tests || ' test' ||
            plural || ' but ran ' || curr_test
        );
    ELSIF num_faild > 0 THEN
        IF raise_ex THEN
            RAISE EXCEPTION  '% test% failed of %', num_faild, CASE num_faild WHEN 1 THEN '' ELSE 's' END, exp_tests;
        END IF;
        RETURN NEXT diag(
            'Looks like you failed ' || num_faild || ' test' ||
            CASE num_faild WHEN 1 THEN '' ELSE 's' END
            || ' of ' || exp_tests
        );
    ELSE

    END IF;
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_fkexists(name, name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT TRUE
           FROM pg_all_foreign_keys
          WHERE fk_schema_name    = $1
            AND quote_ident(fk_table_name)     = quote_ident($2)
            AND fk_columns = $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_fkexists(name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT TRUE
           FROM pg_all_foreign_keys
          WHERE quote_ident(fk_table_name)     = quote_ident($1)
            AND pg_catalog.pg_table_is_visible(fk_table_oid)
            AND fk_columns = $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_fprivs_are(text, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_func_privs($2, $1);
BEGIN
    IF grants[1] = 'undefined_function' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Function ' || $1 || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_func_compare(name, name, anyelement, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN $3 IS NULL
      THEN ok( FALSE, $5 ) || _nosuch($1, $2, '{}')
      ELSE is( $3, $4, $5 )
      END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_func_compare(name, name, boolean, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN $3 IS NULL
      THEN ok( FALSE, $4 ) || _nosuch($1, $2, '{}')
      ELSE ok( $3, $4 )
      END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_func_compare(name, name, name[], anyelement, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN $4 IS NULL
      THEN ok( FALSE, $6 ) || _nosuch($1, $2, $3)
      ELSE is( $4, $5, $6 )
      END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_func_compare(name, name, name[], boolean, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN $4 IS NULL
      THEN ok( FALSE, $5 ) || _nosuch($1, $2, $3)
      ELSE ok( $4, $5 )
      END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_funkargs(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    RETURN array_to_string($1::regtype[], ',');
EXCEPTION WHEN undefined_object THEN
    RETURN array_to_string($1, ',');
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get(text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    ret integer;
BEGIN
    EXECUTE 'SELECT value FROM __tcache__ WHERE label = ' || quote_literal($1) || ' LIMIT 1' INTO ret;
    RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_ac_privs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    privs  TEXT[] := ARRAY['INSERT', 'REFERENCES', 'SELECT', 'UPDATE'];
    grants TEXT[] := '{}';
BEGIN
    FOR i IN 1..array_upper(privs, 1) LOOP
        BEGIN
            IF pg_catalog.has_any_column_privilege($1, $2, privs[i]) THEN
                grants := grants || privs[i];
            END IF;
        EXCEPTION WHEN undefined_table THEN
            -- Not a valid table name.
            RETURN '{undefined_table}';
        WHEN undefined_object THEN
            -- Not a valid role.
            RETURN '{undefined_role}';
        WHEN invalid_parameter_value THEN
            -- Not a valid permission on this version of PostgreSQL; ignore;
        END;
    END LOOP;
    RETURN grants;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_col_ns_type(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[-- Always include the namespace.
    SELECT CASE WHEN pg_catalog.pg_type_is_visible(t.oid)
                THEN quote_ident(tn.nspname) || '.'
                ELSE ''
           END || pg_catalog.format_type(a.atttypid, a.atttypmod)
      FROM pg_catalog.pg_namespace n
      JOIN pg_catalog.pg_class c      ON n.oid = c.relnamespace
      JOIN pg_catalog.pg_attribute a  ON c.oid = a.attrelid
      JOIN pg_catalog.pg_type t       ON a.atttypid = t.oid
      JOIN pg_catalog.pg_namespace tn ON t.typnamespace = tn.oid
     WHERE n.nspname = $1
       AND c.relname = $2
       AND a.attname = $3
       AND attnum    > 0
       AND NOT a.attisdropped]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_col_privs(name, text, name)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    privs  TEXT[] := ARRAY['INSERT', 'REFERENCES', 'SELECT', 'UPDATE'];
    grants TEXT[] := '{}';
BEGIN
    FOR i IN 1..array_upper(privs, 1) LOOP
        IF pg_catalog.has_column_privilege($1, $2, $3, privs[i]) THEN
            grants := grants || privs[i];
        END IF;
    END LOOP;
    RETURN grants;
EXCEPTION
    -- Not a valid column name.
    WHEN undefined_column THEN RETURN '{undefined_column}';
    -- Not a valid table name.
    WHEN undefined_table THEN RETURN '{undefined_table}';
    -- Not a valid role.
    WHEN undefined_object THEN RETURN '{undefined_role}';
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_col_type(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.format_type(a.atttypid, a.atttypmod)
      FROM pg_catalog.pg_attribute a
      JOIN pg_catalog.pg_class c ON  a.attrelid = c.oid
     WHERE pg_catalog.pg_table_is_visible(c.oid)
       AND c.relname = $1
       AND a.attname = $2
       AND attnum    > 0
       AND NOT a.attisdropped]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_col_type(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.format_type(a.atttypid, a.atttypmod)
      FROM pg_catalog.pg_namespace n
      JOIN pg_catalog.pg_class c     ON n.oid = c.relnamespace
      JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
     WHERE n.nspname = $1
       AND c.relname = $2
       AND a.attname = $3
       AND attnum    > 0
       AND NOT a.attisdropped]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_context(name, name)" returnType="&quot;char&quot;" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT c.castcontext
     FROM pg_catalog.pg_cast c
    WHERE _cmp_types(castsource, $1)
      AND _cmp_types(casttarget, $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_db_owner(name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(datdba)
      FROM pg_catalog.pg_database
     WHERE datname = $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_db_privs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    privs  TEXT[] := _db_privs();
    grants TEXT[] := '{}';
BEGIN
    FOR i IN 1..array_upper(privs, 1) LOOP
        BEGIN
            IF pg_catalog.has_database_privilege($1, $2, privs[i]) THEN
                grants := grants || privs[i];
            END IF;
        EXCEPTION WHEN invalid_catalog_name THEN
            -- Not a valid db name.
            RETURN '{invalid_catalog_name}';
        WHEN undefined_object THEN
            -- Not a valid role.
            RETURN '{undefined_role}';
        WHEN invalid_parameter_value THEN
            -- Not a valid permission on this version of PostgreSQL; ignore;
        END;
    END LOOP;
    RETURN grants;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_dtype(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.format_type(t.oid, t.typtypmod)
      FROM pg_catalog.pg_type d
      JOIN pg_catalog.pg_type t  ON d.typbasetype  = t.oid
     WHERE d.typisdefined
       AND pg_catalog.pg_type_is_visible(d.oid)
       AND d.typname = LOWER($1)
       AND d.typtype = 'd']]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_dtype(name, text, boolean)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN $3 AND pg_catalog.pg_type_is_visible(t.oid)
                THEN quote_ident(tn.nspname) || '.'
                ELSE ''
            END || pg_catalog.format_type(t.oid, t.typtypmod)
      FROM pg_catalog.pg_type d
      JOIN pg_catalog.pg_namespace dn ON d.typnamespace = dn.oid
      JOIN pg_catalog.pg_type t       ON d.typbasetype  = t.oid
      JOIN pg_catalog.pg_namespace tn ON t.typnamespace = tn.oid
     WHERE d.typisdefined
       AND dn.nspname = $1
       AND d.typname  = LOWER($2)
       AND d.typtype  = 'd']]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_fdw_privs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF pg_catalog.has_foreign_data_wrapper_privilege($1, $2, 'USAGE') THEN
        RETURN '{USAGE}';
    ELSE
        RETURN '{}';
    END IF;
EXCEPTION WHEN undefined_object THEN
    -- Same error code for unknown user or fdw. So figure out which.
    RETURN CASE WHEN SQLERRM LIKE '%' || $1 || '%' THEN
        '{undefined_role}'
    ELSE
        '{undefined_fdw}'
    END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_func_owner(name, name, name[])" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT owner
      FROM tap_funky
     WHERE schema = $1
       AND name   = $2
       AND args   = array_to_string($3, ',')]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_func_owner(name, name[])" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT owner
      FROM tap_funky
     WHERE name = $1
       AND args = array_to_string($2, ',')
       AND is_visible]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_func_privs(text, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF pg_catalog.has_function_privilege($1, $2, 'EXECUTE') THEN
        RETURN '{EXECUTE}';
    ELSE
        RETURN '{}';
    END IF;
EXCEPTION
    -- Not a valid func name.
    WHEN undefined_function THEN RETURN '{undefined_function}';
    -- Not a valid role.
    WHEN undefined_object   THEN RETURN '{undefined_role}';
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_index_owner(name, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(ci.relowner)
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
     WHERE ct.relname = $1
       AND ci.relname = $2
       AND pg_catalog.pg_table_is_visible(ct.oid);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_index_owner(name, name, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(ci.relowner)
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
     WHERE n.nspname  = $1
       AND ct.relname = $2
       AND ci.relname = $3;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_lang_privs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF pg_catalog.has_language_privilege($1, $2, 'USAGE') THEN
        RETURN '{USAGE}';
    ELSE
        RETURN '{}';
    END IF;
EXCEPTION WHEN undefined_object THEN
    -- Same error code for unknown user or language. So figure out which.
    RETURN CASE WHEN SQLERRM LIKE '%' || $1 || '%' THEN
        '{undefined_role}'
    ELSE
        '{undefined_language}'
    END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_language_owner(name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(lanowner)
      FROM pg_catalog.pg_language
     WHERE lanname = $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_latest(text)" returnType="integer[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    ret integer[];
BEGIN
    EXECUTE 'SELECT ARRAY[id, value] FROM __tcache__ WHERE label = ' ||
    quote_literal($1) || ' AND id = (SELECT MAX(id) FROM __tcache__ WHERE label = ' ||
    quote_literal($1) || ') LIMIT 1' INTO ret;
    RETURN ret;
EXCEPTION WHEN undefined_table THEN
   RAISE EXCEPTION 'You tried to run a test without a plan! Gotta have a plan';
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_latest(text, integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    ret integer;
BEGIN
    EXECUTE 'SELECT MAX(id) FROM __tcache__ WHERE label = ' ||
    quote_literal($1) || ' AND value = ' || $2 INTO ret;
    RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_note(integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    ret text;
BEGIN
    EXECUTE 'SELECT note FROM __tcache__ WHERE id = ' || $1 || ' LIMIT 1' INTO ret;
    RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_note(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    ret text;
BEGIN
    EXECUTE 'SELECT note FROM __tcache__ WHERE label = ' || quote_literal($1) || ' LIMIT 1' INTO ret;
    RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_opclass_owner(name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(opcowner)
      FROM pg_catalog.pg_opclass
     WHERE opcname = $1
       AND pg_catalog.pg_opclass_is_visible(oid);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_opclass_owner(name, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(opcowner)
      FROM pg_catalog.pg_opclass oc
      JOIN pg_catalog.pg_namespace n ON oc.opcnamespace = n.oid
     WHERE n.nspname = $1
       AND opcname   = $2;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_rel_owner(character, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _get_rel_owner(ARRAY[$1], $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_rel_owner(character, name, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _get_rel_owner(ARRAY[$1], $2, $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_rel_owner(character[], name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(c.relowner)
      FROM pg_catalog.pg_class c
     WHERE c.relkind = ANY($1)
       AND c.relname = $2
       AND pg_catalog.pg_table_is_visible(c.oid)]]></definition>
         <parameters>
            <parameter mode="IN" type="character[]"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_rel_owner(character[], name, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(c.relowner)
      FROM pg_catalog.pg_class c
      JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
     WHERE c.relkind = ANY($1)
       AND n.nspname = $2
       AND c.relname = $3]]></definition>
         <parameters>
            <parameter mode="IN" type="character[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_rel_owner(name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(c.relowner)
      FROM pg_catalog.pg_class c
     WHERE c.relname = $1
       AND pg_catalog.pg_table_is_visible(c.oid)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_rel_owner(name, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(c.relowner)
      FROM pg_catalog.pg_class c
      JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
     WHERE n.nspname = $1
       AND c.relname = $2]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_schema_owner(name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(nspowner)
      FROM pg_catalog.pg_namespace
     WHERE nspname = $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_schema_privs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    privs  TEXT[] := ARRAY['CREATE', 'USAGE'];
    grants TEXT[] := '{}';
BEGIN
    FOR i IN 1..array_upper(privs, 1) LOOP
        IF pg_catalog.has_schema_privilege($1, $2, privs[i]) THEN
            grants := grants || privs[i];
        END IF;
    END LOOP;
    RETURN grants;
EXCEPTION
    -- Not a valid schema name.
    WHEN invalid_schema_name THEN RETURN '{invalid_schema_name}';
    -- Not a valid role.
    WHEN undefined_object   THEN RETURN '{undefined_role}';
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_sequence_privs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    privs  TEXT[] := ARRAY['SELECT', 'UPDATE', 'USAGE'];
    grants TEXT[] := '{}';
BEGIN
    FOR i IN 1..array_upper(privs, 1) LOOP
        BEGIN
            IF pg_catalog.has_sequence_privilege($1, $2, privs[i]) THEN
                grants := grants || privs[i];
            END IF;
        EXCEPTION WHEN undefined_table THEN
            -- Not a valid sequence name.
            RETURN '{undefined_table}';
        WHEN undefined_object THEN
            -- Not a valid role.
            RETURN '{undefined_role}';
        WHEN invalid_parameter_value THEN
            -- Not a valid permission on this version of PostgreSQL; ignore;
        END;
    END LOOP;
    RETURN grants;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_server_privs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF pg_catalog.has_server_privilege($1, $2, 'USAGE') THEN
        RETURN '{USAGE}';
    ELSE
        RETURN '{}';
    END IF;
EXCEPTION WHEN undefined_object THEN
    -- Same error code for unknown user or server. So figure out which.
    RETURN CASE WHEN SQLERRM LIKE '%' || $1 || '%' THEN
        '{undefined_role}'
    ELSE
        '{undefined_server}'
    END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_table_privs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    privs  TEXT[] := _table_privs();
    grants TEXT[] := '{}';
BEGIN
    FOR i IN 1..array_upper(privs, 1) LOOP
        BEGIN
            IF pg_catalog.has_table_privilege($1, $2, privs[i]) THEN
                grants := grants || privs[i];
            END IF;
        EXCEPTION WHEN undefined_table THEN
            -- Not a valid table name.
            RETURN '{undefined_table}';
        WHEN undefined_object THEN
            -- Not a valid role.
            RETURN '{undefined_role}';
        WHEN invalid_parameter_value THEN
            -- Not a valid permission on this version of PostgreSQL; ignore;
        END;
    END LOOP;
    RETURN grants;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_tablespace_owner(name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(spcowner)
      FROM pg_catalog.pg_tablespace
     WHERE spcname = $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_tablespaceprivs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF pg_catalog.has_tablespace_privilege($1, $2, 'CREATE') THEN
        RETURN '{CREATE}';
    ELSE
        RETURN '{}';
    END IF;
EXCEPTION WHEN undefined_object THEN
    -- Same error code for unknown user or tablespace. So figure out which.
    RETURN CASE WHEN SQLERRM LIKE '%' || $1 || '%' THEN
        '{undefined_role}'
    ELSE
        '{undefined_tablespace}'
    END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_type_owner(name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(typowner)
      FROM pg_catalog.pg_type
     WHERE typname = $1
       AND pg_catalog.pg_type_is_visible(oid)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_get_type_owner(name, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT pg_catalog.pg_get_userbyid(t.typowner)
      FROM pg_catalog.pg_type t
      JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
     WHERE n.nspname = $1
       AND t.typname = $2]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_got_func(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS( SELECT TRUE FROM tap_funky WHERE name = $1 AND is_visible);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_got_func(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS( SELECT TRUE FROM tap_funky WHERE schema = $1 AND name = $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_got_func(name, name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT TRUE
          FROM tap_funky
         WHERE schema = $1
           AND name   = $2
           AND args = _funkargs($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_got_func(name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT TRUE
          FROM tap_funky
         WHERE name = $1
           AND args = _funkargs($2)
           AND is_visible
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_grolist(name)" returnType="oid[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT member
          FROM pg_catalog.pg_auth_members m
          JOIN pg_catalog.pg_roles r ON m.roleid = r.oid
         WHERE r.rolname =  $1
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_has_def(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT a.atthasdef
      FROM pg_catalog.pg_class c
      JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
     WHERE c.relname = $1
       AND a.attnum > 0
       AND NOT a.attisdropped
       AND a.attname = $2
       AND pg_catalog.pg_table_is_visible(c.oid)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_has_def(name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT a.atthasdef
      FROM pg_catalog.pg_namespace n
      JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
      JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
     WHERE n.nspname = $1
       AND c.relname = $2
       AND a.attnum > 0
       AND NOT a.attisdropped
       AND a.attname = $3]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_has_group(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_group
         WHERE groname = $1
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_has_role(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_roles
         WHERE rolname = $1
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_has_type(name, character[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_type t
         WHERE t.typisdefined
           AND pg_catalog.pg_type_is_visible(t.oid)
           AND t.typname = $1
           AND t.typtype = ANY( COALESCE($2, ARRAY['b', 'c', 'd', 'p', 'e']) )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_has_type(name, name, character[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_type t
          JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
         WHERE t.typisdefined
           AND n.nspname = $1
           AND t.typname = $2
           AND t.typtype = ANY( COALESCE($3, ARRAY['b', 'c', 'd', 'p', 'e']) )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_has_user(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS( SELECT true FROM pg_catalog.pg_user WHERE usename = $1);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_hasc(name, character)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
            SELECT true
              FROM pg_catalog.pg_class c
              JOIN pg_catalog.pg_constraint x ON c.oid = x.conrelid
             WHERE pg_table_is_visible(c.oid)
               AND c.relname = $1
               AND x.contype = $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_hasc(name, name, character)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
            SELECT true
              FROM pg_catalog.pg_namespace n
              JOIN pg_catalog.pg_class c      ON c.relnamespace = n.oid
              JOIN pg_catalog.pg_constraint x ON c.oid = x.conrelid
             WHERE n.nspname = $1
               AND c.relname = $2
               AND x.contype = $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_have_index(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
    SELECT TRUE
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
     WHERE ct.relname = $1
       AND ci.relname = $2
       AND pg_catalog.pg_table_is_visible(ct.oid)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_have_index(name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
    SELECT TRUE
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
     WHERE n.nspname  = $1
       AND ct.relname = $2
       AND ci.relname = $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_ident_array_to_sorted_string(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT array_to_string(ARRAY(
        SELECT quote_ident($1[i])
          FROM generate_series(1, array_upper($1, 1)) s(i)
         ORDER BY $1[i]
    ), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_ident_array_to_string(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT array_to_string(ARRAY(
        SELECT quote_ident($1[i])
          FROM generate_series(1, array_upper($1, 1)) s(i)
         ORDER BY i
    ), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_ikeys(name, name)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT pg_catalog.pg_get_indexdef( ci.oid, s.i + 1, false)
          FROM pg_catalog.pg_index x
          JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
          JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
          JOIN generate_series(0, current_setting('max_index_keys')::int - 1) s(i)
            ON x.indkey[s.i] IS NOT NULL
         WHERE ct.relname = $1
           AND ci.relname = $2
           AND pg_catalog.pg_table_is_visible(ct.oid)
         ORDER BY s.i
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_ikeys(name, name, name)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT pg_catalog.pg_get_indexdef( ci.oid, s.i + 1, false)
          FROM pg_catalog.pg_index x
          JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
          JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
          JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
          JOIN generate_series(0, current_setting('max_index_keys')::int - 1) s(i)
            ON x.indkey[s.i] IS NOT NULL
         WHERE ct.relname = $2
           AND ci.relname = $3
           AND n.nspname  = $1
         ORDER BY s.i
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_inherited(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_class c
         WHERE c.relkind = 'r'
           AND pg_catalog.pg_table_is_visible( c.oid )
           AND c.relname = $1
           AND c.relhassubclass = true
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_inherited(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_namespace n
          JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
         WHERE c.relkind = 'r'
           AND n.nspname = $1
           AND c.relname = $2
           AND c.relhassubclass = true
  );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_is_indexed(name, name, text[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS( SELECT TRUE FROM (
        SELECT _ikeys(coalesce($1, n.nspname), $2, ci.relname) AS cols
          FROM pg_catalog.pg_index x
          JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
          JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
          JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
         WHERE ($1 IS NULL OR n.nspname  = $1)
           AND ct.relname = $2
    ) icols
    WHERE cols = $3 )]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_is_instead(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT r.is_instead
      FROM pg_catalog.pg_rewrite r
      JOIN pg_catalog.pg_class c     ON c.oid = r.ev_class
     WHERE r.rulename = $2
       AND c.relname  = $1
       AND pg_catalog.pg_table_is_visible(c.oid)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_is_instead(name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT r.is_instead
      FROM pg_catalog.pg_rewrite r
      JOIN pg_catalog.pg_class c     ON c.oid = r.ev_class
      JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
     WHERE r.rulename = $3
       AND c.relname  = $2
       AND n.nspname  = $1]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_is_schema(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_namespace
          WHERE nspname = $1
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_is_super(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT rolsuper
      FROM pg_catalog.pg_roles
     WHERE rolname = $1]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_is_trusted(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT lanpltrusted FROM pg_catalog.pg_language WHERE lanname = $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_is_verbose()" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT current_setting('client_min_messages') NOT IN (
        'warning', 'error', 'fatal', 'panic'
    );]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_keys(name, character)" returnType="SETOF name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _pg_sv_column_array(x.conrelid,x.conkey) -- name[] doesn't support collation
      FROM pg_catalog.pg_class c
      JOIN pg_catalog.pg_constraint x  ON c.oid = x.conrelid
       AND c.relname = $1
       AND x.contype = $2
     WHERE pg_catalog.pg_table_is_visible(c.oid)
  ORDER BY 1]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_keys(name, name, character)" returnType="SETOF name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _pg_sv_column_array(x.conrelid,x.conkey) -- name[] doesn't support collation
      FROM pg_catalog.pg_namespace n
      JOIN pg_catalog.pg_class c       ON n.oid = c.relnamespace
      JOIN pg_catalog.pg_constraint x  ON c.oid = x.conrelid
     WHERE n.nspname = $1
       AND c.relname = $2
       AND x.contype = $3
  ORDER BY 1]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="character"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_lang(name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT l.lanname
      FROM tap_funky f
      JOIN pg_catalog.pg_language l ON f.langoid = l.oid
     WHERE f.name = $1
       AND f.is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_lang(name, name)" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT l.lanname
      FROM tap_funky f
      JOIN pg_catalog.pg_language l ON f.langoid = l.oid
     WHERE f.schema = $1
       and f.name   = $2]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_lang(name, name, name[])" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT l.lanname
      FROM tap_funky f
      JOIN pg_catalog.pg_language l ON f.langoid = l.oid
     WHERE f.schema = $1
       and f.name   = $2
       AND f.args   = array_to_string($3, ',')]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_lang(name, name[])" returnType="name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT l.lanname
      FROM tap_funky f
      JOIN pg_catalog.pg_language l ON f.langoid = l.oid
     WHERE f.name = $1
       AND f.args = array_to_string($2, ',')
       AND f.is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_missing(character, name, name[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _missing(ARRAY[$1], $2, $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_missing(character, name[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _missing(ARRAY[$1], $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_missing(character[], name, name[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT $3[i]
          FROM generate_series(1, array_upper($3, 1)) s(i)
        EXCEPT
        SELECT c.relname
          FROM pg_catalog.pg_namespace n
          JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
         WHERE c.relkind = ANY($1)
           AND n.nspname = $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="character[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_missing(character[], name[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT $2[i]
          FROM generate_series(1, array_upper($2, 1)) s(i)
        EXCEPT
        SELECT c.relname
          FROM pg_catalog.pg_namespace n
          JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
         WHERE pg_catalog.pg_table_is_visible(c.oid)
           AND n.nspname NOT IN ('pg_catalog', 'information_schema')
           AND c.relkind = ANY($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="character[]"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_nosuch(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT E'\n' || diag(
        '    Function '
          || CASE WHEN $1 IS NOT NULL THEN quote_ident($1) || '.' ELSE '' END
          || quote_ident($2) || '('
          || array_to_string($3, ', ') || ') does not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_op_exists(name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
       SELECT TRUE
         FROM pg_catalog.pg_operator o
        WHERE pg_catalog.pg_operator_is_visible(o.oid)
          AND o.oprname = $2
          AND CASE o.oprkind WHEN 'l' THEN $1 IS NULL
              ELSE _cmp_types(o.oprleft, $1) END
          AND CASE o.oprkind WHEN 'r' THEN $3 IS NULL
              ELSE _cmp_types(o.oprright, $3) END
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_op_exists(name, name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
       SELECT TRUE
         FROM pg_catalog.pg_operator o
        WHERE pg_catalog.pg_operator_is_visible(o.oid)
          AND o.oprname = $2
          AND CASE o.oprkind WHEN 'l' THEN $1 IS NULL
              ELSE _cmp_types(o.oprleft, $1) END
          AND CASE o.oprkind WHEN 'r' THEN $3 IS NULL
              ELSE _cmp_types(o.oprright, $3) END
          AND _cmp_types(o.oprresult, $4)
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_op_exists(name, name, name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
       SELECT TRUE
         FROM pg_catalog.pg_operator o
         JOIN pg_catalog.pg_namespace n ON o.oprnamespace = n.oid
        WHERE n.nspname = $2
          AND o.oprname = $3
          AND CASE o.oprkind WHEN 'l' THEN $1 IS NULL
              ELSE _cmp_types(o.oprleft, $1) END
          AND CASE o.oprkind WHEN 'r' THEN $4 IS NULL
              ELSE _cmp_types(o.oprright, $4) END
          AND _cmp_types(o.oprresult, $5)
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_opc_exists(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
        SELECT TRUE
          FROM pg_catalog.pg_opclass oc
         WHERE oc.opcname = $1
           AND pg_opclass_is_visible(oid)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_opc_exists(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS (
        SELECT TRUE
          FROM pg_catalog.pg_opclass oc
          JOIN pg_catalog.pg_namespace n ON oc.opcnamespace = n.oid
         WHERE n.nspname  = $1
           AND oc.opcname = $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_partof(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_class cc
          JOIN pg_catalog.pg_inherits i ON cc.oid = i.inhrelid
          JOIN pg_catalog.pg_class pc ON i.inhparent = pc.oid
         WHERE cc.relname = $1
           AND cc.relispartition
           AND pc.relname = $2
           AND pc.relkind = 'p'
           AND pg_catalog.pg_table_is_visible(cc.oid)
           AND pg_catalog.pg_table_is_visible(pc.oid)
    )]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_partof(name, name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_namespace cn
          JOIN pg_catalog.pg_class cc ON cn.oid = cc.relnamespace
          JOIN pg_catalog.pg_inherits i ON cc.oid = i.inhrelid
          JOIN pg_catalog.pg_class pc ON i.inhparent = pc.oid
          JOIN pg_catalog.pg_namespace pn ON pc.relnamespace = pn.oid
         WHERE cn.nspname = $1
           AND cc.relname = $2
           AND cc.relispartition
           AND pn.nspname = $3
           AND pc.relname = $4
           AND pc.relkind = 'p'
    )]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_parts(name)" returnType="SETOF name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT i.inhrelid::regclass::name
      FROM pg_catalog.pg_class c
      JOIN pg_catalog.pg_inherits i ON c.oid = i.inhparent
     WHERE c.relname = $1
       AND c.relkind = 'p'
       AND pg_catalog.pg_table_is_visible(c.oid)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_parts(name, name)" returnType="SETOF name" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT i.inhrelid::regclass::name
      FROM pg_catalog.pg_namespace n
      JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
      JOIN pg_catalog.pg_inherits i ON c.oid = i.inhparent
     WHERE n.nspname = $1
       AND c.relname = $2
       AND c.relkind = 'p']]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_pg_sv_column_array(oid, smallint[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT a.attname
          FROM pg_catalog.pg_attribute a
          JOIN generate_series(1, array_upper($2, 1)) s(i) ON a.attnum = $2[i]
         WHERE attrelid = $1
         ORDER BY i
    )]]></definition>
         <parameters>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="smallint[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_pg_sv_table_accessible(oid, oid)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN has_schema_privilege($1, 'USAGE') THEN (
                  has_table_privilege($2, 'SELECT')
               OR has_table_privilege($2, 'INSERT')
               or has_table_privilege($2, 'UPDATE')
               OR has_table_privilege($2, 'DELETE')
               OR has_table_privilege($2, 'RULE')
               OR has_table_privilege($2, 'REFERENCES')
               OR has_table_privilege($2, 'TRIGGER')
           ) ELSE FALSE
    END;]]></definition>
         <parameters>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="oid"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_pg_sv_type_array(oid[])" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT t.typname
          FROM pg_catalog.pg_type t
          JOIN generate_series(1, array_upper($1, 1)) s(i) ON t.oid = $1[i]
         ORDER BY i
    )]]></definition>
         <parameters>
            <parameter mode="IN" type="oid[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_prokind(p_oid oid)" returnType="&quot;char&quot;" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF pg_version_num() >= 110000 THEN
        RETURN prokind FROM pg_catalog.pg_proc WHERE oid = p_oid;
    ELSE
        RETURN CASE WHEN proisagg THEN 'a' WHEN proiswindow THEN 'w' ELSE 'f' END
            FROM pg_catalog.pg_proc WHERE oid = p_oid;
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_oid" type="oid"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_query(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE
        WHEN $1 LIKE '"%' OR $1 !~ '[[:space:]]' THEN 'EXECUTE ' || $1
        ELSE $1
    END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_quote_ident_like(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have    TEXT;
    pcision TEXT;
BEGIN
    -- Just return it if rhs isn't quoted.
    IF $2 !~ '"' THEN RETURN $1; END IF;

    -- If it's quoted ident without precision, return it quoted.
    IF $2 ~ '"$' THEN RETURN quote_ident($1); END IF;

    pcision := substring($1 FROM '[(][^")]+[)]$');

    -- Just quote it if thre is no precision.
    if pcision IS NULL THEN RETURN quote_ident($1); END IF;

    -- Quote the non-precision part and concatenate with precision.
    RETURN quote_ident(substring($1 FOR char_length($1) - char_length(pcision)))
        || pcision;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_refine_vol(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _expand_vol(substring(LOWER($1) FROM 1 FOR 1)::char);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_relcomp(text, anyarray, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _docomp(
        _temptable( $1, '__taphave__' ),
        _temptable( $2, '__tapwant__' ),
        $3, $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_relcomp(text, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _docomp(
        _temptable( $1, '__taphave__' ),
        _temptable( $2, '__tapwant__' ),
        $3, $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_relcomp(text, text, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have    TEXT    := _temptable( $1, '__taphave__' );
    want    TEXT    := _temptable( $2, '__tapwant__' );
    results TEXT[]  := '{}';
    res     BOOLEAN := TRUE;
    msg     TEXT    := '';
    rec     RECORD;
BEGIN
    BEGIN
        -- Find relevant records.
        FOR rec in EXECUTE 'SELECT * FROM ' || want || ' ' || $4
                       || ' SELECT * FROM ' || have LOOP
            results := results || rec::text;
        END LOOP;

        -- Drop the temporary tables.
        EXECUTE 'DROP TABLE ' || have;
        EXECUTE 'DROP TABLE ' || want;
    EXCEPTION WHEN syntax_error OR datatype_mismatch THEN
        msg := E'\n' || diag(
            E'    Columns differ between queries:\n'
            || '        have: (' || _temptypes(have) || E')\n'
            || '        want: (' || _temptypes(want) || ')'
        );
        EXECUTE 'DROP TABLE ' || have;
        EXECUTE 'DROP TABLE ' || want;
        RETURN ok(FALSE, $3) || msg;
    END;

    -- What records do we have?
    IF results[1] IS NOT NULL THEN
        res := FALSE;
        msg := msg || E'\n' || diag(
            '    ' || $5 || E' records:\n        '
            ||  array_to_string( results, E'\n        ' )
        );
    END IF;

    RETURN ok(res, $3) || msg;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_relexists(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_class c
         WHERE pg_catalog.pg_table_is_visible(c.oid)
           AND c.relname = $1
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_relexists(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_namespace n
          JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
         WHERE n.nspname = $1
           AND c.relname = $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_relne(text, anyarray, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _do_ne(
        _temptable( $1, '__taphave__' ),
        _temptable( $2, '__tapwant__' ),
        $3, $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_relne(text, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _do_ne(
        _temptable( $1, '__taphave__' ),
        _temptable( $2, '__tapwant__' ),
        $3, $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_returns(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT returns FROM tap_funky WHERE name = $1 AND is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_returns(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT returns FROM tap_funky WHERE schema = $1 AND name = $2]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_returns(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT returns
      FROM tap_funky
     WHERE schema = $1
       AND name   = $2
       AND args   = array_to_string($3, ',')]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_returns(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT returns
      FROM tap_funky
     WHERE name = $1
       AND args = array_to_string($2, ',')
       AND is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_rexists(character, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _rexists(ARRAY[$1], $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_rexists(character, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _rexists(ARRAY[$1], $2, $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_rexists(character[], name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_class c
         WHERE c.relkind = ANY($1)
           AND pg_catalog.pg_table_is_visible(c.oid)
           AND c.relname = $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="character[]"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_rexists(character[], name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_namespace n
          JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
         WHERE c.relkind = ANY($1)
           AND n.nspname = $2
           AND c.relname = $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="character[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_rule_on(name, name)" returnType="&quot;char&quot;" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT r.ev_type
      FROM pg_catalog.pg_rewrite r
      JOIN pg_catalog.pg_class c     ON c.oid = r.ev_class
     WHERE r.rulename = $2
       AND c.relname  = $1]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_rule_on(name, name, name)" returnType="&quot;char&quot;" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT r.ev_type
      FROM pg_catalog.pg_rewrite r
      JOIN pg_catalog.pg_class c     ON c.oid = r.ev_class
      JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
     WHERE r.rulename = $3
       AND c.relname  = $2
       AND n.nspname  = $1]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_runem(text[], boolean)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    tap    text;
    lbound int := array_lower($1, 1);
BEGIN
    IF lbound IS NULL THEN RETURN; END IF;
    FOR i IN lbound..array_upper($1, 1) LOOP
        -- Send the name of the function to diag if warranted.
        IF $2 THEN RETURN NEXT diag( $1[i] || '()' ); END IF;
        -- Execute the tap function and return its results.
        FOR tap IN EXECUTE 'SELECT * FROM ' || $1[i] || '()' LOOP
            RETURN NEXT tap;
        END LOOP;
    END LOOP;
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_runner(text[], text[], text[], text[], text[])" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    startup  ALIAS FOR $1;
    shutdown ALIAS FOR $2;
    setup    ALIAS FOR $3;
    teardown ALIAS FOR $4;
    tests    ALIAS FOR $5;
    tap      TEXT;
    tfaild   INTEGER := 0;
    ffaild   INTEGER := 0;
    tnumb    INTEGER := 0;
    fnumb    INTEGER := 0;
    tok      BOOLEAN := TRUE;
BEGIN
    BEGIN
        -- No plan support.
        PERFORM * FROM no_plan();
        FOR tap IN SELECT * FROM _runem(startup, false) LOOP RETURN NEXT tap; END LOOP;
    EXCEPTION
        -- Catch all exceptions and simply rethrow custom exceptions. This
        -- will roll back everything in the above block.
        WHEN raise_exception THEN RAISE EXCEPTION '%', SQLERRM;
    END;

    -- Record how startup tests have failed.
    tfaild := num_failed();

    FOR i IN 1..COALESCE(array_upper(tests, 1), 0) LOOP

        -- What subtest are we running?
        RETURN NEXT '    ' || diag_test_name('Subtest: ' || tests[i]);

        -- Reset the results.
        tok := TRUE;
        tnumb := COALESCE(_get('curr_test'), 0);

        IF tnumb > 0 THEN
            EXECUTE 'ALTER SEQUENCE __tresults___numb_seq RESTART WITH 1';
            PERFORM _set('curr_test', 0);
            PERFORM _set('failed', 0);
        END IF;

        DECLARE
            errstate text;
            errmsg   text;
            detail   text;
            hint     text;
            context  text;
            schname  text;
            tabname  text;
            colname  text;
            chkname  text;
            typname  text;
        BEGIN
            BEGIN
                -- Run the setup functions.
                FOR tap IN SELECT * FROM _runem(setup, false) LOOP
                    RETURN NEXT regexp_replace(tap, '^', '    ', 'gn');
                END LOOP;

                -- Run the actual test function.
                FOR tap IN EXECUTE 'SELECT * FROM ' || tests[i] || '()' LOOP
                    RETURN NEXT regexp_replace(tap, '^', '    ', 'gn');
                END LOOP;

                -- Run the teardown functions.
                FOR tap IN SELECT * FROM _runem(teardown, false) LOOP
                    RETURN NEXT regexp_replace(tap, '^', '    ', 'gn');
                END LOOP;

                -- Emit the plan.
                fnumb := COALESCE(_get('curr_test'), 0);
                RETURN NEXT '    1..' || fnumb;

                -- Emit any error messages.
                IF fnumb = 0 THEN
                    RETURN NEXT '    # No tests run!';
                    tok = false;
                ELSE
                    -- Report failures.
                    ffaild := num_failed();
                    IF ffaild > 0 THEN
                        tok := FALSE;
                        RETURN NEXT '    ' || diag(
                            'Looks like you failed ' || ffaild || ' test' ||
                             CASE tfaild WHEN 1 THEN '' ELSE 's' END
                             || ' of ' || fnumb
                        );
                    END IF;
                END IF;

            EXCEPTION WHEN raise_exception THEN
                -- Something went wrong. Record that fact.
                errstate := SQLSTATE;
                errmsg := SQLERRM;
                GET STACKED DIAGNOSTICS
                    detail  = PG_EXCEPTION_DETAIL,
                    hint    = PG_EXCEPTION_HINT,
                    context = PG_EXCEPTION_CONTEXT,
                    schname = SCHEMA_NAME,
                    tabname = TABLE_NAME,
                    colname = COLUMN_NAME,
                    chkname = CONSTRAINT_NAME,
                    typname = PG_DATATYPE_NAME;
            END;

            -- Always raise an exception to rollback any changes.
            RAISE EXCEPTION '__TAP_ROLLBACK__';

        EXCEPTION WHEN raise_exception THEN
            IF errmsg IS NOT NULL THEN
                -- Something went wrong. Emit the error message.
                tok := FALSE;
               RETURN NEXT regexp_replace( diag('Test died: ' || _error_diag(
                   errstate, errmsg, detail, hint, context, schname, tabname, colname, chkname, typname
               )), '^', '    ', 'gn');
                errmsg := NULL;
            END IF;
        END;

        -- Restore the sequence.
        EXECUTE 'ALTER SEQUENCE __tresults___numb_seq RESTART WITH ' || tnumb + 1;
        PERFORM _set('curr_test', tnumb);
        PERFORM _set('failed', tfaild);

        -- Record this test.
        RETURN NEXT ok(tok, tests[i]);
        IF NOT tok THEN tfaild := tfaild + 1; END IF;

    END LOOP;

    -- Run the shutdown functions.
    FOR tap IN SELECT * FROM _runem(shutdown, false) LOOP RETURN NEXT tap; END LOOP;

    -- Finish up.
    FOR tap IN SELECT * FROM _finish( COALESCE(_get('curr_test'), 0), 0, tfaild ) LOOP
        RETURN NEXT tap;
    END LOOP;

    -- Clean up and return.
    PERFORM _cleanup();
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_set(integer, integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    EXECUTE 'UPDATE __tcache__ SET value = ' || $2
        || ' WHERE id = ' || $1;
    RETURN $2;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_set(text, integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _set($1, $2, '')]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_set(text, integer, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    rcount integer;
BEGIN
    EXECUTE 'UPDATE __tcache__ SET value = ' || $2
        || CASE WHEN $3 IS NULL THEN '' ELSE ', note = ' || quote_literal($3) END
        || ' WHERE label = ' || quote_literal($1);
    GET DIAGNOSTICS rcount = ROW_COUNT;
    IF rcount = 0 THEN
       RETURN _add( $1, $2, $3 );
    END IF;
    RETURN $2;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_strict(name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_strict FROM tap_funky WHERE name = $1 AND is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_strict(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_strict FROM tap_funky WHERE schema = $1 AND name = $2]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_strict(name, name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_strict
      FROM tap_funky
     WHERE schema = $1
       AND name   = $2
       AND args   = array_to_string($3, ',')]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_strict(name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_strict
      FROM tap_funky
     WHERE name = $1
       AND args = array_to_string($2, ',')
       AND is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_table_privs()" returnType="name[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    pgversion INTEGER := pg_version_num();
BEGIN
    IF pgversion < 80200 THEN RETURN ARRAY[
        'DELETE', 'INSERT', 'REFERENCES', 'RULE', 'SELECT', 'TRIGGER', 'UPDATE'
    ];
    ELSIF pgversion < 80400 THEN RETURN ARRAY[
        'DELETE', 'INSERT', 'REFERENCES', 'SELECT', 'TRIGGER', 'UPDATE'
    ];
    ELSE RETURN ARRAY[
        'DELETE', 'INSERT', 'REFERENCES', 'SELECT', 'TRIGGER', 'TRUNCATE', 'UPDATE'
    ];
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_temptable(anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    CREATE TEMP TABLE _____coltmp___ AS
    SELECT $1[i]
    FROM generate_series(array_lower($1, 1), array_upper($1, 1)) s(i);
    EXECUTE 'ALTER TABLE _____coltmp___ RENAME TO ' || $2;
    return $2;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_temptable(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    EXECUTE 'CREATE TEMP TABLE ' || $2 || ' AS ' || _query($1);
    return $2;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_temptypes(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT array_to_string(ARRAY(
        SELECT pg_catalog.format_type(a.atttypid, a.atttypmod)
          FROM pg_catalog.pg_attribute a
          JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
         WHERE c.oid = ('pg_temp.' || $1)::pg_catalog.regclass
           AND attnum > 0
           AND NOT attisdropped
         ORDER BY attnum
    ), ',');]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_time_trials(text, integer, numeric)" returnType="SETOF _time_trial_type" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    query            TEXT := _query($1);
    iterations       ALIAS FOR $2;
    return_percent   ALIAS FOR $3;
    start_time       TEXT;
    act_time         NUMERIC;
    times            NUMERIC[];
    offset_it        INT;
    limit_it         INT;
    offset_percent   NUMERIC;
    a_time	     _time_trial_type;
BEGIN
    -- Execute the query over and over
    FOR i IN 1..iterations LOOP
        start_time := timeofday();
        EXECUTE query;
        -- Store the execution time for the run in an array of times
        times[i] := extract(millisecond from timeofday()::timestamptz - start_time::timestamptz);
    END LOOP;
    offset_percent := (1.0 - return_percent) / 2.0;
    -- Ensure that offset skips the bottom X% of runs, or set it to 0
    SELECT GREATEST((offset_percent * iterations)::int, 0) INTO offset_it;
    -- Ensure that with limit the query to returning only the middle X% of runs
    SELECT GREATEST((return_percent * iterations)::int, 1) INTO limit_it;

    FOR a_time IN SELECT times[i]
		  FROM generate_series(array_lower(times, 1), array_upper(times, 1)) i
                  ORDER BY 1
                  OFFSET offset_it
                  LIMIT limit_it LOOP
	RETURN NEXT a_time;
    END LOOP;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="numeric"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_tlike(boolean, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( $1, $4 ) || CASE WHEN $1 THEN '' ELSE E'\n' || diag(
           '   error message: ' || COALESCE( quote_literal($2), 'NULL' ) ||
       E'\n   doesn''t match: ' || COALESCE( quote_literal($3), 'NULL' )
    ) END;]]></definition>
         <parameters>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_todo()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    todos INT[];
    note text;
BEGIN
    -- Get the latest id and value, because todo() might have been called
    -- again before the todos ran out for the first call to todo(). This
    -- allows them to nest.
    todos := _get_latest('todo');
    IF todos IS NULL THEN
        -- No todos.
        RETURN NULL;
    END IF;
    IF todos[2] = 0 THEN
        -- Todos depleted. Clean up.
        EXECUTE 'DELETE FROM __tcache__ WHERE id = ' || todos[1];
        RETURN NULL;
    END IF;
    -- Decrement the count of counted todos and return the reason.
    IF todos[2] <> -1 THEN
        PERFORM _set(todos[1], todos[2] - 1);
    END IF;
    note := _get_note(todos[1]);

    IF todos[2] = 1 THEN
        -- This was the last todo, so delete the record.
        EXECUTE 'DELETE FROM __tcache__ WHERE id = ' || todos[1];
    END IF;

    RETURN note;
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_trig(name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_trigger t
          JOIN pg_catalog.pg_class c     ON c.oid = t.tgrelid
         WHERE c.relname = $1
           AND t.tgname  = $2
           AND pg_catalog.pg_table_is_visible(c.oid)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_trig(name, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT EXISTS(
        SELECT true
          FROM pg_catalog.pg_trigger t
          JOIN pg_catalog.pg_class c     ON c.oid = t.tgrelid
          JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
         WHERE n.nspname = $1
           AND c.relname = $2
           AND t.tgname  = $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_type_func(&quot;char&quot;, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT kind = $1 FROM tap_funky WHERE name = $2 AND is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="&quot;char&quot;"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_type_func(&quot;char&quot;, name, name)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT kind = $1 FROM tap_funky WHERE schema = $2 AND name = $3]]></definition>
         <parameters>
            <parameter mode="IN" type="&quot;char&quot;"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_type_func(&quot;char&quot;, name, name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT kind = $1
      FROM tap_funky
     WHERE schema = $2
       AND name   = $3
       AND args   = array_to_string($4, ',')]]></definition>
         <parameters>
            <parameter mode="IN" type="&quot;char&quot;"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_type_func(&quot;char&quot;, name, name[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT kind = $1
      FROM tap_funky
     WHERE name = $2
       AND args = array_to_string($3, ',')
       AND is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="&quot;char&quot;"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_types_are(name, name[], text, character[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'types',
        ARRAY(
            SELECT t.typname
              FROM pg_catalog.pg_type t
              LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
             WHERE (
                     t.typrelid = 0
                 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)
             )
               AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
               AND n.nspname = $1
               AND t.typtype = ANY( COALESCE($4, ARRAY['b', 'c', 'd', 'p', 'e']) )
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
               FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT t.typname
              FROM pg_catalog.pg_type t
              LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
             WHERE (
                     t.typrelid = 0
                 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)
             )
               AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
               AND n.nspname = $1
               AND t.typtype = ANY( COALESCE($4, ARRAY['b', 'c', 'd', 'p', 'e']) )
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="character[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_types_are(name[], text, character[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'types',
        ARRAY(
            SELECT t.typname
              FROM pg_catalog.pg_type t
              LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
             WHERE (
                     t.typrelid = 0
                 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)
             )
               AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND pg_catalog.pg_type_is_visible(t.oid)
               AND t.typtype = ANY( COALESCE($3, ARRAY['b', 'c', 'd', 'p', 'e']) )
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
               FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT t.typname
              FROM pg_catalog.pg_type t
              LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
             WHERE (
                     t.typrelid = 0
                 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)
             )
               AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND pg_catalog.pg_type_is_visible(t.oid)
               AND t.typtype = ANY( COALESCE($3, ARRAY['b', 'c', 'd', 'p', 'e']) )
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="character[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_unalike(boolean, anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    result ALIAS FOR $1;
    got    ALIAS FOR $2;
    rx     ALIAS FOR $3;
    descr  ALIAS FOR $4;
    output TEXT;
BEGIN
    output := ok( result, descr );
    RETURN output || CASE result WHEN TRUE THEN '' ELSE E'\n' || diag(
           '                  ' || COALESCE( quote_literal(got), 'NULL' ) ||
        E'\n         matches: ' || COALESCE( quote_literal(rx), 'NULL' )
    ) END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_vol(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _expand_vol(volatility) FROM tap_funky f
     WHERE f.name = $1 AND f.is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_vol(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _expand_vol(volatility) FROM tap_funky f
     WHERE f.schema = $1 and f.name = $2]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_vol(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _expand_vol(volatility)
      FROM tap_funky f
     WHERE f.schema = $1
       and f.name   = $2
       AND f.args   = array_to_string($3, ',')]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_vol(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _expand_vol(volatility)
      FROM tap_funky f
     WHERE f.name = $1
       AND f.args = array_to_string($2, ',')
       AND f.is_visible;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="add_result(boolean, boolean, text, text, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF NOT $1 THEN PERFORM _set('failed', _get('failed') + 1); END IF;
    RETURN nextval('__tresults___numb_seq');
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="akeys(hstore)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_akeys]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="alike(anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _alike( $1 ~~ $2, $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="alike(anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _alike( $1 ~~ $2, $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="any_column_privs_are(name, name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT any_column_privs_are(
        $1, $2, $3, $4,
        'Role ' || quote_ident($3) || ' should be granted '
            || CASE WHEN $4[1] IS NULL THEN 'no privileges' ELSE array_to_string($4, ', ') END
            || ' on any column in '|| quote_ident($1) || '.' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="any_column_privs_are(name, name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_ac_privs( $3, quote_ident($1) || '.' || quote_ident($2) );
BEGIN
    IF grants[1] = 'undefined_table' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Table ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Role ' || quote_ident($3) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $4, $5);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="any_column_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT any_column_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on any column in ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="any_column_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_ac_privs( $2, quote_ident($1) );
BEGIN
    IF grants[1] = 'undefined_table' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Table ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="armor(bytea)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_armor]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="armor(bytea, text[], text[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_armor]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="avals(hstore)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_avals]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_eq(text, anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, NULL::text, 'ALL ' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_eq(text, anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, $3, 'ALL ' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_eq(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, NULL::text, 'ALL ' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_eq(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, $3, 'ALL ' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_has(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, NULL::TEXT, 'EXCEPT ALL', 'Missing' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_has(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, $3, 'EXCEPT ALL', 'Missing' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_hasnt(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, NULL::TEXT, 'INTERSECT ALL', 'Extra' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_hasnt(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, $3, 'INTERSECT ALL', 'Extra' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_ne(text, anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relne( $1, $2, NULL::text, 'ALL ' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_ne(text, anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relne( $1, $2, $3, 'ALL ' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_ne(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relne( $1, $2, NULL::text, 'ALL ' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bag_ne(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relne( $1, $2, $3, 'ALL ' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="can(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT can( $1, $2, 'Schema ' || quote_ident($1) || ' can' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="can(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    missing text[];
BEGIN
    SELECT ARRAY(
        SELECT quote_ident($2[i])
          FROM generate_series(1, array_upper($2, 1)) s(i)
          LEFT JOIN tap_funky ON name = $2[i] AND schema = $1
         WHERE oid IS NULL
         GROUP BY $2[i], s.i
         ORDER BY MIN(s.i)
    ) INTO missing;
    IF missing[1] IS NULL THEN
        RETURN ok( true, $3 );
    END IF;
    RETURN ok( false, $3 ) || E'\n' || diag(
        '    ' || quote_ident($1) || '.' ||
        array_to_string( missing, E'() missing\n    ' || quote_ident($1) || '.') ||
        '() missing'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="can(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT can( $1, 'Schema ' || _ident_array_to_string(current_schemas(true), ' or ') || ' can' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="can(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    missing text[];
BEGIN
    SELECT ARRAY(
        SELECT quote_ident($1[i])
          FROM generate_series(1, array_upper($1, 1)) s(i)
          LEFT JOIN pg_catalog.pg_proc p
            ON $1[i] = p.proname
           AND pg_catalog.pg_function_is_visible(p.oid)
         WHERE p.oid IS NULL
         ORDER BY s.i
    ) INTO missing;
    IF missing[1] IS NULL THEN
        RETURN ok( true, $2 );
    END IF;
    RETURN ok( false, $2 ) || E'\n' || diag(
        '    ' ||
        array_to_string( missing, E'() missing\n    ') ||
        '() missing'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="cash_dist(money, money)" returnType="money" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[cash_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="money"/>
            <parameter mode="IN" type="money"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cast_context_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT cast_context_is(
        $1, $2, $3,
        'Cast (' || quote_ident($1) || ' AS ' || quote_ident($2)
        || ') context should be ' || _expand_context(substring(LOWER($3) FROM 1 FOR 1))
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cast_context_is(name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    want char = substring(LOWER($3) FROM 1 FOR 1);
    have char := _get_context($1, $2);
BEGIN
    IF have IS NOT NULL THEN
        RETURN is( _expand_context(have), _expand_context(want), $4 );
    END IF;

    RETURN ok( false, $4 ) || E'\n' || diag(
       '    Cast (' || quote_ident($1) || ' AS ' || quote_ident($2)
      || ') does not exist'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="casts_are(text[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT casts_are( $1, 'There should be the correct casts');]]></definition>
         <parameters>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="casts_are(text[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _areni(
        'casts',
        ARRAY(
            SELECT pg_catalog.format_type(castsource, NULL)
                   || ' AS ' || pg_catalog.format_type(casttarget, NULL)
              FROM pg_catalog.pg_cast c
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT pg_catalog.format_type(castsource, NULL)
                   || ' AS ' || pg_catalog.format_type(casttarget, NULL)
              FROM pg_catalog.pg_cast c
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="check_test(text, boolean)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM check_test( $1, $2, NULL, NULL, NULL, FALSE );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="check_test(text, boolean, text)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM check_test( $1, $2, $3, NULL, NULL, FALSE );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="check_test(text, boolean, text, text)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM check_test( $1, $2, $3, $4, NULL, FALSE );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="check_test(text, boolean, text, text, text)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM check_test( $1, $2, $3, $4, $5, FALSE );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="check_test(text, boolean, text, text, text, boolean)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    tnumb   INTEGER;
    aok     BOOLEAN;
    adescr  TEXT;
    res     BOOLEAN;
    descr   TEXT;
    adiag   TEXT;
    have    ALIAS FOR $1;
    eok     ALIAS FOR $2;
    name    ALIAS FOR $3;
    edescr  ALIAS FOR $4;
    ediag   ALIAS FOR $5;
    matchit ALIAS FOR $6;
BEGIN
    -- What test was it that just ran?
    tnumb := currval('__tresults___numb_seq');

    -- Fetch the results.
    aok    := substring(have, 1, 2) = 'ok';
    adescr := COALESCE(substring(have FROM  E'(?:not )?ok [[:digit:]]+ - ([^\n]+)'), '');

    -- Now delete those results.
    EXECUTE 'ALTER SEQUENCE __tresults___numb_seq RESTART WITH ' || tnumb;
    IF NOT aok THEN PERFORM _set('failed', _get('failed') - 1); END IF;

    -- Set up the description.
    descr := coalesce( name || ' ', 'Test ' ) || 'should ';

    -- So, did the test pass?
    RETURN NEXT is(
        aok,
        eok,
        descr || CASE eok WHEN true then 'pass' ELSE 'fail' END
    );

    -- Was the description as expected?
    IF edescr IS NOT NULL THEN
        RETURN NEXT is(
            adescr,
            edescr,
            descr || 'have the proper description'
        );
    END IF;

    -- Were the diagnostics as expected?
    IF ediag IS NOT NULL THEN
        -- Remove ok and the test number.
        adiag := substring(
            have
            FROM CASE WHEN aok THEN 4 ELSE 9 END + char_length(tnumb::text)
        );

        -- Remove the description, if there is one.
        IF adescr <> '' THEN
            adiag := substring(
                adiag FROM 1 + char_length( ' - ' || substr(diag( adescr ), 3) )
            );
        END IF;

        IF NOT aok THEN
            -- Remove failure message from ok().
            adiag := substring(adiag FROM 1 + char_length(diag(
                'Failed test ' || tnumb ||
                CASE adescr WHEN '' THEN '' ELSE COALESCE(': "' || adescr || '"', '') END
            )));
        END IF;

        IF ediag <> '' THEN
           -- Remove the space before the diagnostics.
           adiag := substring(adiag FROM 2);
        END IF;

        -- Remove the #s.
        adiag := replace( substring(adiag from 3), E'\n# ', E'\n' );

        -- Now compare the diagnostics.
        IF matchit THEN
            RETURN NEXT matches(
                adiag,
                ediag,
                descr || 'have the proper diagnostics'
            );
        ELSE
            RETURN NEXT is(
                adiag,
                ediag,
                descr || 'have the proper diagnostics'
            );
        END IF;
    END IF;

    -- And we're done
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cmp_ok(anyelement, text, anyelement)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT cmp_ok( $1, $2, $3, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cmp_ok(anyelement, text, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have   ALIAS FOR $1;
    op     ALIAS FOR $2;
    want   ALIAS FOR $3;
    descr  ALIAS FOR $4;
    result BOOLEAN;
    output TEXT;
BEGIN
    EXECUTE 'SELECT ' ||
            COALESCE(quote_literal( have ), 'NULL') || '::' || pg_typeof(have) || ' '
            || op || ' ' ||
            COALESCE(quote_literal( want ), 'NULL') || '::' || pg_typeof(want)
       INTO result;
    output := ok( COALESCE(result, FALSE), descr );
    RETURN output || CASE result WHEN TRUE THEN '' ELSE E'\n' || diag(
           '    ' || COALESCE( quote_literal(have), 'NULL' ) ||
           E'\n        ' || op ||
           E'\n    ' || COALESCE( quote_literal(want), 'NULL' )
    ) END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_default_is(name, name, anyelement)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _cdi( $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_default_is(name, name, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _cdi( $1, $2, $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_default_is(name, name, name, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _cdi( $1, $2, $3, $4, $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_default_is(name, name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _cdi( $1, $2, $3, $4, $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_default_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _cdi( $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_default_is(name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _cdi( $1, $2, $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_check(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_has_check( $1, $2, 'Column ' || quote_ident($1) || '(' || quote_ident($2) || ') should have a check constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_check(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_has_check( $1, $2, ARRAY[$3], $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_check(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _constraint( $1, $2, 'c', $3, $4, 'check' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_check(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_has_check( $1, ARRAY[$2], $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_check(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_has_check( $1, $2, 'Columns ' || quote_ident($1) || '(' || _ident_array_to_string($2, ', ') || ') should have a check constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_check(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _constraint( $1, 'c', $2, $3, 'check' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_default(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_has_default( $1, $2, 'Column ' || quote_ident($1) || '.' || quote_ident($2) || ' should have a default' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_default(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF NOT _cexists( $1, $2, $3 ) THEN
        RETURN fail( $4 ) || E'\n'
            || diag ('    Column ' || quote_ident($1) || '.' || quote_ident($2) || '.' || quote_ident($3) || ' does not exist' );
    END IF;
    RETURN ok( _has_def( $1, $2, $3 ), $4 );
END]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_has_default(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF NOT _cexists( $1, $2 ) THEN
        RETURN fail( $3 ) || E'\n'
            || diag ('    Column ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist' );
    END IF;
    RETURN ok( _has_def( $1, $2 ), $3 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_hasnt_default(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_hasnt_default( $1, $2, 'Column ' || quote_ident($1) || '.' || quote_ident($2) || ' should not have a default' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_hasnt_default(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF NOT _cexists( $1, $2, $3 ) THEN
        RETURN fail( $4 ) || E'\n'
            || diag ('    Column ' || quote_ident($1) || '.' || quote_ident($2) || '.' || quote_ident($3) || ' does not exist' );
    END IF;
    RETURN ok( NOT _has_def( $1, $2, $3 ), $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_hasnt_default(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF NOT _cexists( $1, $2 ) THEN
        RETURN fail( $3 ) || E'\n'
            || diag ('    Column ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist' );
    END IF;
    RETURN ok( NOT _has_def( $1, $2 ), $3 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_fk(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_fk( $1, $2, 'Column ' || quote_ident($1) || '(' || quote_ident($2) || ') should be a foreign key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_fk(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_fk( $1, $2, ARRAY[$3], $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_fk(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    names text[];
BEGIN
    IF _fkexists($1, $2, $3) THEN
        RETURN pass( $4 );
    END IF;

    -- Try to show the columns.
    SELECT ARRAY(
        SELECT _ident_array_to_string(fk_columns, ', ')
          FROM pg_all_foreign_keys
         WHERE fk_schema_name = $1
           AND fk_table_name  = $2
         ORDER BY fk_columns
    ) INTO names;

    IF names[1] IS NOT NULL THEN
        RETURN fail($4) || E'\n' || diag(
            '    Table ' || quote_ident($1) || '.' || quote_ident($2) || E' has foreign key constraints on these columns:\n        '
            ||  array_to_string( names, E'\n        ' )
        );
    END IF;

    -- No FKs in this table.
    RETURN fail($4) || E'\n' || diag(
        '    Table ' || quote_ident($1) || '.' || quote_ident($2) || ' has no foreign key columns'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_fk(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_fk( $1, ARRAY[$2], $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_fk(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_fk( $1, $2, 'Columns ' || quote_ident($1) || '(' || _ident_array_to_string($2, ', ') || ') should be a foreign key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_fk(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    names text[];
BEGIN
    IF _fkexists($1, $2) THEN
        RETURN pass( $3 );
    END IF;

    -- Try to show the columns.
    SELECT ARRAY(
        SELECT _ident_array_to_string(fk_columns, ', ')
          FROM pg_all_foreign_keys
         WHERE fk_table_name  = $1
         ORDER BY fk_columns
    ) INTO names;

    IF NAMES[1] IS NOT NULL THEN
        RETURN fail($3) || E'\n' || diag(
            '    Table ' || quote_ident($1) || E' has foreign key constraints on these columns:\n        '
            || array_to_string( names, E'\n        ' )
        );
    END IF;

    -- No FKs in this table.
    RETURN fail($3) || E'\n' || diag(
        '    Table ' || quote_ident($1) || ' has no foreign key columns'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_null(schema_name name, table_name name, column_name name, description text DEFAULT NULL::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _col_is_null( $1, $2, $3, $4, false );]]></definition>
         <parameters>
            <parameter mode="IN" name="schema_name" type="name"/>
            <parameter mode="IN" name="table_name" type="name"/>
            <parameter mode="IN" name="column_name" type="name"/>
            <parameter mode="IN" name="description" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_null(table_name name, column_name name, description text DEFAULT NULL::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _col_is_null( $1, $2, $3, false );]]></definition>
         <parameters>
            <parameter mode="IN" name="table_name" type="name"/>
            <parameter mode="IN" name="column_name" type="name"/>
            <parameter mode="IN" name="description" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_pk(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_pk( $1, $2, 'Column ' || quote_ident($1) || '(' || quote_ident($2) || ') should be a primary key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_pk(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_pk( $1, $2, ARRAY[$3], $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_pk(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is( _ckeys( $1, $2, 'p' ), $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_pk(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_pk( $1, ARRAY[$2], $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_pk(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_pk( $1, $2, 'Columns ' || quote_ident($1) || '(' || _ident_array_to_string($2, ', ') || ') should be a primary key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_pk(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is( _ckeys( $1, 'p' ), $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_unique(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_unique( $1, $2, 'Column ' || quote_ident($1) || '(' || quote_ident($2) || ') should have a unique constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_unique(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_unique( $1, $2, ARRAY[$3], 'Column ' || quote_ident($2) || '(' || quote_ident($3) || ') should have a unique constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_unique(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_unique( $1, $2, ARRAY[$3], $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_unique(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_unique( $1, $2, $3, 'Columns ' || quote_ident($2) || '(' || _ident_array_to_string($3, ', ') || ') should have a unique constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_unique(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _constraint( $1, $2, 'u', $3, $4, 'unique' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_unique(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_unique( $1, ARRAY[$2], $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_unique(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_is_unique( $1, $2, 'Columns ' || quote_ident($1) || '(' || _ident_array_to_string($2, ', ') || ') should have a unique constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_is_unique(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _constraint( $1, 'u', $2, $3, 'unique' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_fk(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_isnt_fk( $1, $2, 'Column ' || quote_ident($1) || '(' || quote_ident($2) || ') should not be a foreign key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_fk(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_isnt_fk( $1, $2, ARRAY[$3], $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_fk(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _fkexists( $1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_fk(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_isnt_fk( $1, ARRAY[$2], $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_fk(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_isnt_fk( $1, $2, 'Columns ' || quote_ident($1) || '(' || _ident_array_to_string($2, ', ') || ') should not be a foreign key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_fk(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _fkexists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_pk(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_isnt_pk( $1, $2, 'Column ' || quote_ident($1) || '(' || quote_ident($2) || ') should not be a primary key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_pk(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_isnt_pk( $1, $2, ARRAY[$3], $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_pk(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isnt( _ckeys( $1, $2, 'p' ), $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_pk(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_isnt_pk( $1, ARRAY[$2], $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_pk(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_isnt_pk( $1, $2, 'Columns ' || quote_ident($1) || '(' || _ident_array_to_string($2, ', ') || ') should not be a primary key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_isnt_pk(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isnt( _ckeys( $1, 'p' ), $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_not_null(schema_name name, table_name name, column_name name, description text DEFAULT NULL::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _col_is_null( $1, $2, $3, $4, true );]]></definition>
         <parameters>
            <parameter mode="IN" name="schema_name" type="name"/>
            <parameter mode="IN" name="table_name" type="name"/>
            <parameter mode="IN" name="column_name" type="name"/>
            <parameter mode="IN" name="description" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_not_null(table_name name, column_name name, description text DEFAULT NULL::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _col_is_null( $1, $2, $3, true );]]></definition>
         <parameters>
            <parameter mode="IN" name="table_name" type="name"/>
            <parameter mode="IN" name="column_name" type="name"/>
            <parameter mode="IN" name="description" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_type_is(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_type_is( $1, $2, $3, $4, $5, 'Column ' || quote_ident($1) || '.' || quote_ident($2)
        || '.' || quote_ident($3) || ' should be type ' || quote_ident($4) || '.' || $5);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_type_is(name, name, name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have_type TEXT := _get_col_ns_type($1, $2, $3);
    want_type TEXT;
BEGIN
    IF have_type IS NULL THEN
        RETURN fail( $6 ) || E'\n' || diag (
            '   Column ' || COALESCE(quote_ident($1) || '.', '')
            || quote_ident($2) || '.' || quote_ident($3) || ' does not exist'
        );
    END IF;

    want_type := quote_ident($4) || '.' || _quote_ident_like($5, have_type);
    IF have_type = want_type THEN
        -- We're good to go.
        RETURN ok( true, $6 );
    END IF;

    -- Wrong data type. tell 'em what we really got.
    RETURN ok( false, $6 ) || E'\n' || diag(
           '        have: ' || have_type ||
        E'\n        want: ' || want_type
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_type_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_type_is( $1, $2, $3, $4, 'Column ' || quote_ident($1) || '.' || quote_ident($2) || '.' || quote_ident($3) || ' should be type ' || $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_type_is(name, name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have_type TEXT;
    want_type TEXT;
BEGIN
    -- Get the data type.
    IF $1 IS NULL THEN
        have_type := _get_col_type($2, $3);
    ELSE
        have_type := _get_col_type($1, $2, $3);
    END IF;

    IF have_type IS NULL THEN
        RETURN fail( $5 ) || E'\n' || diag (
            '   Column ' || COALESCE(quote_ident($1) || '.', '')
            || quote_ident($2) || '.' || quote_ident($3) || ' does not exist'
        );
    END IF;

    want_type := _quote_ident_like($4, have_type);
    IF have_type = want_type THEN
        -- We're good to go.
        RETURN ok( true, $5 );
    END IF;

    -- Wrong data type. tell 'em what we really got.
    RETURN ok( false, $5 ) || E'\n' || diag(
           '        have: ' || have_type ||
        E'\n        want: ' || want_type
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_type_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_type_is( $1, $2, $3, 'Column ' || quote_ident($1) || '.' || quote_ident($2) || ' should be type ' || $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="col_type_is(name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT col_type_is( NULL, $1, $2, $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="collect_tap(VARIADIC text[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT array_to_string($1, E'\n');]]></definition>
         <parameters>
            <parameter mode="VARIADIC" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="collect_tap(character varying[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT array_to_string($1, E'\n');]]></definition>
         <parameters>
            <parameter mode="IN" type="character varying[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="column_privs_are(name, name, name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT column_privs_are(
        $1, $2, $3, $4, $5,
        'Role ' || quote_ident($4) || ' should be granted '
            || CASE WHEN $5[1] IS NULL THEN 'no privileges' ELSE array_to_string($5, ', ') END
            || ' on column ' || quote_ident($1) || '.' || quote_ident($2) || '.' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="column_privs_are(name, name, name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_col_privs( $4, quote_ident($1) || '.' || quote_ident($2), $3 );
BEGIN
    IF grants[1] = 'undefined_column' THEN
        RETURN ok(FALSE, $6) || E'\n' || diag(
            '    Column ' || quote_ident($1) || '.' || quote_ident($2) || '.' || quote_ident($3)
            || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_table' THEN
        RETURN ok(FALSE, $6) || E'\n' || diag(
            '    Table ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $6) || E'\n' || diag(
            '    Role ' || quote_ident($4) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $5, $6);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="column_privs_are(name, name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT column_privs_are(
        $1, $2, $3, $4,
        'Role ' || quote_ident($3) || ' should be granted '
            || CASE WHEN $4[1] IS NULL THEN 'no privileges' ELSE array_to_string($4, ', ') END
            || ' on column ' || quote_ident($1) || '.' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="column_privs_are(name, name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_col_privs( $3, quote_ident($1), $2 );
BEGIN
    IF grants[1] = 'undefined_column' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Column ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_table' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Table ' || quote_ident($1) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Role ' || quote_ident($3) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $4, $5);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="columns_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT columns_are( $1, $2, $3, 'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should have the correct columns' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="columns_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'columns',
        ARRAY(
            SELECT a.attname
              FROM pg_catalog.pg_namespace n
              JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
              JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
             WHERE n.nspname = $1
               AND c.relname = $2
               AND a.attnum > 0
               AND NOT a.attisdropped
            EXCEPT
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
        ),
        ARRAY(
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
            EXCEPT
            SELECT a.attname
              FROM pg_catalog.pg_namespace n
              JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
              JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
             WHERE n.nspname = $1
               AND c.relname = $2
               AND a.attnum > 0
               AND NOT a.attisdropped
        ),
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="columns_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT columns_are( $1, $2, 'Table ' || quote_ident($1) || ' should have the correct columns' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="columns_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'columns',
        ARRAY(
            SELECT a.attname
              FROM pg_catalog.pg_namespace n
              JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
              JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
             WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND pg_catalog.pg_table_is_visible(c.oid)
               AND c.relname = $1
               AND a.attnum > 0
               AND NOT a.attisdropped
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT a.attname
              FROM pg_catalog.pg_namespace n
              JOIN pg_catalog.pg_class c ON n.oid = c.relnamespace
              JOIN pg_catalog.pg_attribute a ON c.oid = a.attrelid
             WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND pg_catalog.pg_table_is_visible(c.oid)
               AND c.relname = $1
               AND a.attnum > 0
               AND NOT a.attisdropped
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="composite_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT composite_owner_is(
        $1, $2,
        'Composite type ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="composite_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT composite_owner_is(
        $1, $2, $3,
        'Composite type ' || quote_ident($1) || '.' || quote_ident($2) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="composite_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('c'::char, $1, $2);
BEGIN
    -- Make sure the composite exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Composite type ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="composite_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('c'::char, $1);
BEGIN
    -- Make sure the composite exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Composite type ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="crypt(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_crypt]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="database_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT database_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on database ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="database_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_db_privs( $2, $1::TEXT );
BEGIN
    IF grants[1] = 'invalid_catalog_name' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Database ' || quote_ident($1) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="date_dist(date, date)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[date_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="date"/>
            <parameter mode="IN" type="date"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="db_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT db_owner_is(
        $1, $2,
        'Database ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="db_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    dbowner NAME := _get_db_owner($1);
BEGIN
    -- Make sure the database exists.
    IF dbowner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Database ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(dbowner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="dearmor(text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_dearmor]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="decrypt(bytea, bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_decrypt]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="decrypt_iv(bytea, bytea, bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_decrypt_iv]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="defined(hstore, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_defined]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="delete(hstore, hstore)" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_delete_hstore]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="delete(hstore, text)" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_delete]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="delete(hstore, text[])" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_delete_array]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="diag(VARIADIC anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT diag(array_to_string($1, ''));]]></definition>
         <parameters>
            <parameter mode="VARIADIC" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="diag(VARIADIC text[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT diag(array_to_string($1, ''));]]></definition>
         <parameters>
            <parameter mode="VARIADIC" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="diag(msg anyelement)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT diag($1::text);]]></definition>
         <parameters>
            <parameter mode="IN" name="msg" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="diag(msg text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT '# ' || replace(
       replace(
            replace( $1, E'\r\n', E'\n# ' ),
            E'\n',
            E'\n# '
        ),
        E'\r',
        E'\n# '
    );]]></definition>
         <parameters>
            <parameter mode="IN" name="msg" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="diag_test_name(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT diag($1 || '()');]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="digest(bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_digest]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="digest(text, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_digest]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="display_oper(name, oid)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT $1 || substring($2::regoperator::text, '[(][^)]+[)]$')]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="oid"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="do_tap()" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _runem( findfuncs('^test'), _is_verbose());]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="do_tap(name)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _runem( findfuncs($1, '^test'), _is_verbose() );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="do_tap(name, text)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _runem( findfuncs($1, $2), _is_verbose() );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="do_tap(text)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _runem( findfuncs($1), _is_verbose() );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="doesnt_imatch(anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _unalike( $1 !~* $2, $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="doesnt_imatch(anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _unalike( $1 !~* $2, $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="doesnt_match(anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _unalike( $1 !~ $2, $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="doesnt_match(anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _unalike( $1 !~ $2, $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_is(name, text, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT domain_type_is(
        $1, $2, $3, $4,
        'Domain ' || quote_ident($1) || '.' || $2
        || ' should extend type ' || quote_ident($3) || '.' || $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_is(name, text, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    actual_type TEXT := _get_dtype($1, $2, true);
BEGIN
    IF actual_type IS NULL THEN
        RETURN fail( $5 ) || E'\n' || diag (
            '   Domain ' || quote_ident($1) || '.' || $2
            || ' does not exist'
        );
    END IF;

    RETURN is( actual_type, quote_ident($3) || '.' || _quote_ident_like($4, actual_type), $5 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_is(name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT domain_type_is(
        $1, $2, $3,
        'Domain ' || quote_ident($1) || '.' || $2
        || ' should extend type ' || $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_is(name, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    actual_type TEXT := _get_dtype($1, $2, false);
BEGIN
    IF actual_type IS NULL THEN
        RETURN fail( $4 ) || E'\n' || diag (
            '   Domain ' || quote_ident($1) || '.' || $2
            || ' does not exist'
        );
    END IF;

    RETURN is( actual_type, _quote_ident_like($3, actual_type), $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_is(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT domain_type_is(
        $1, $2,
        'Domain ' || $1 || ' should extend type ' || $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_is(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    actual_type TEXT := _get_dtype($1);
BEGIN
    IF actual_type IS NULL THEN
        RETURN fail( $3 ) || E'\n' || diag (
            '   Domain ' ||  $1 || ' does not exist'
        );
    END IF;

    RETURN is( actual_type, _quote_ident_like($2, actual_type), $3 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_isnt(name, text, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT domain_type_isnt(
        $1, $2, $3, $4,
        'Domain ' || quote_ident($1) || '.' || $2
        || ' should not extend type ' || quote_ident($3) || '.' || $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_isnt(name, text, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    actual_type TEXT := _get_dtype($1, $2, true);
BEGIN
    IF actual_type IS NULL THEN
        RETURN fail( $5 ) || E'\n' || diag (
            '   Domain ' || quote_ident($1) || '.' || $2
            || ' does not exist'
        );
    END IF;

    RETURN isnt( actual_type, quote_ident($3) || '.' || _quote_ident_like($4, actual_type), $5 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_isnt(name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT domain_type_isnt(
        $1, $2, $3,
        'Domain ' || quote_ident($1) || '.' || $2
        || ' should not extend type ' || $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_isnt(name, text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    actual_type TEXT := _get_dtype($1, $2, false);
BEGIN
    IF actual_type IS NULL THEN
        RETURN fail( $4 ) || E'\n' || diag (
            '   Domain ' || quote_ident($1) || '.' || $2
            || ' does not exist'
        );
    END IF;

    RETURN isnt( actual_type, _quote_ident_like($3, actual_type), $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_isnt(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT domain_type_isnt(
        $1, $2,
        'Domain ' || $1 || ' should not extend type ' || $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domain_type_isnt(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    actual_type TEXT := _get_dtype($1);
BEGIN
    IF actual_type IS NULL THEN
        RETURN fail( $3 ) || E'\n' || diag (
            '   Domain ' ||  $1 || ' does not exist'
        );
    END IF;

    RETURN isnt( actual_type, _quote_ident_like($2, actual_type), $3 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domains_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, 'Schema ' || quote_ident($1) || ' should have the correct domains', ARRAY['d'] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domains_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, $3, ARRAY['d'] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domains_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, 'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct domains', ARRAY['d'] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="domains_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, ARRAY['d'] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="each(hs hstore, OUT key text, OUT value text)" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_each]]></definition>
         <parameters>
            <parameter mode="IN" name="hs" type="hstore"/>
            <parameter mode="OUT" name="key" type="text"/>
            <parameter mode="OUT" name="value" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="encrypt(bytea, bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_encrypt]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="encrypt_iv(bytea, bytea, bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_encrypt_iv]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enum_has_labels(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT enum_has_labels(
        $1, $2, $3,
        'Enum ' || quote_ident($1) || '.' || quote_ident($2) || ' should have labels (' || array_to_string( $3, ', ' ) || ')'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enum_has_labels(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is(
        ARRAY(
            SELECT e.enumlabel
              FROM pg_catalog.pg_type t
              JOIN pg_catalog.pg_enum e      ON t.oid = e.enumtypid
              JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid
              WHERE t.typisdefined
               AND n.nspname = $1
               AND t.typname = $2
               AND t.typtype = 'e'
             ORDER BY e.enumsortorder
        ),
        $3,
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enum_has_labels(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT enum_has_labels(
        $1, $2,
        'Enum ' || quote_ident($1) || ' should have labels (' || array_to_string( $2, ', ' ) || ')'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enum_has_labels(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is(
        ARRAY(
            SELECT e.enumlabel
              FROM pg_catalog.pg_type t
              JOIN pg_catalog.pg_enum e ON t.oid = e.enumtypid
              WHERE t.typisdefined
               AND pg_catalog.pg_type_is_visible(t.oid)
               AND t.typname = $1
               AND t.typtype = 'e'
             ORDER BY e.enumsortorder
        ),
        $2,
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enums_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, 'Schema ' || quote_ident($1) || ' should have the correct enums', ARRAY['e'] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enums_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, $3, ARRAY['e'] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enums_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, 'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct enums', ARRAY['e'] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enums_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, ARRAY['e'] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="exist(hstore, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_exists]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="exists_all(hstore, text[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_exists_all]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="exists_any(hstore, text[])" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_exists_any]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="extensions_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT extensions_are(
        $1, $2,
        'Schema ' || quote_ident($1) || ' should have the correct extensions'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="extensions_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'extensions',
        ARRAY(SELECT _extensions($1) EXCEPT SELECT unnest($2)),
        ARRAY(SELECT unnest($2) EXCEPT SELECT _extensions($1)),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="extensions_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT extensions_are($1, 'Should have the correct extensions');]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="extensions_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'extensions',
        ARRAY(SELECT _extensions() EXCEPT SELECT unnest($1)),
        ARRAY(SELECT unnest($1) EXCEPT SELECT _extensions()),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fail()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( FALSE, NULL );]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fail(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( FALSE, $1 );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fdw_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT fdw_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on FDW ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fdw_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_fdw_privs( $2, $1::TEXT );
BEGIN
    IF grants[1] = 'undefined_fdw' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    FDW ' || quote_ident($1) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="fetchval(hstore, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_fetchval]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="findfuncs(name, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT findfuncs( $1, $2, NULL )]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="findfuncs(name, text, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT DISTINCT (quote_ident(n.nspname) || '.' || quote_ident(p.proname)) COLLATE "C" AS pname
          FROM pg_catalog.pg_proc p
          JOIN pg_catalog.pg_namespace n ON p.pronamespace = n.oid
         WHERE n.nspname = $1
           AND p.proname ~ $2
           AND ($3 IS NULL OR p.proname !~ $3)
         ORDER BY pname
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="findfuncs(text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT findfuncs( $1, NULL )]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="findfuncs(text, text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ARRAY(
        SELECT DISTINCT (quote_ident(n.nspname) || '.' || quote_ident(p.proname)) COLLATE "C" AS pname
          FROM pg_catalog.pg_proc p
          JOIN pg_catalog.pg_namespace n ON p.pronamespace = n.oid
         WHERE pg_catalog.pg_function_is_visible(p.oid)
           AND p.proname ~ $1
           AND ($2 IS NULL OR p.proname !~ $2)
         ORDER BY pname
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="finish(exception_on_failure boolean DEFAULT NULL::boolean)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _finish(
        _get('curr_test'),
        _get('plan'),
        num_failed(),
        $1
    );]]></definition>
         <parameters>
            <parameter mode="IN" name="exception_on_failure" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fk_ok(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT fk_ok( $1, ARRAY[$2], $3, ARRAY[$4] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fk_ok(name, name, name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT fk_ok( $1, $2, ARRAY[$3], $4, $5, ARRAY[$6], $7 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fk_ok(name, name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT fk_ok( $1, $2, ARRAY[$3], $4, $5, ARRAY[$6] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fk_ok(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT fk_ok( $1, ARRAY[$2], $3, ARRAY[$4], $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fk_ok(name, name, name[], name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT fk_ok( $1, $2, $3, $4, $5, $6,
        quote_ident($1) || '.' || quote_ident($2) || '(' || _ident_array_to_string( $3, ', ' )
        || ') should reference ' ||
        $4 || '.' || $5 || '(' || _ident_array_to_string( $6, ', ' ) || ')'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fk_ok(name, name, name[], name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    sch  name;
    tab  name;
    cols name[];
BEGIN
    SELECT pk_schema_name, pk_table_name, pk_columns
      FROM pg_all_foreign_keys
      WHERE fk_schema_name = $1
        AND fk_table_name  = $2
        AND fk_columns     = $3
      INTO sch, tab, cols;

    RETURN is(
        -- have
        quote_ident($1) || '.' || quote_ident($2) || '(' || _ident_array_to_string( $3, ', ' )
        || ') REFERENCES ' || COALESCE ( sch || '.' || tab || '(' || _ident_array_to_string( cols, ', ' ) || ')', 'NOTHING' ),
        -- want
        quote_ident($1) || '.' || quote_ident($2) || '(' || _ident_array_to_string( $3, ', ' )
        || ') REFERENCES ' ||
        $4 || '.' || $5 || '(' || _ident_array_to_string( $6, ', ' ) || ')',
        $7
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fk_ok(name, name[], name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT fk_ok( $1, $2, $3, $4,
        $1 || '(' || _ident_array_to_string( $2, ', ' )
        || ') should reference ' ||
        $3 || '(' || _ident_array_to_string( $4, ', ' ) || ')'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fk_ok(name, name[], name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    tab  name;
    cols name[];
BEGIN
    SELECT pk_table_name, pk_columns
      FROM pg_all_foreign_keys
     WHERE fk_table_name = $1
       AND fk_columns    = $2
       AND pg_catalog.pg_table_is_visible(fk_table_oid)
      INTO tab, cols;

    RETURN is(
        -- have
        $1 || '(' || _ident_array_to_string( $2, ', ' )
        || ') REFERENCES ' || COALESCE( tab || '(' || _ident_array_to_string( cols, ', ' ) || ')', 'NOTHING'),
        -- want
        $1 || '(' || _ident_array_to_string( $2, ', ' )
        || ') REFERENCES ' ||
        $3 || '(' || _ident_array_to_string( $4, ', ' ) || ')',
        $5
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="float4_dist(real, real)" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[float4_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="real"/>
            <parameter mode="IN" type="real"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="float8_dist(double precision, double precision)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[float8_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="foreign_table_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT foreign_table_owner_is(
        $1, $2,
        'Foreign table ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="foreign_table_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT foreign_table_owner_is(
        $1, $2, $3,
        'Foreign table ' || quote_ident($1) || '.' || quote_ident($2) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="foreign_table_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('f'::char, $1, $2);
BEGIN
    -- Make sure the table exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Foreign table ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="foreign_table_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('f'::char, $1);
BEGIN
    -- Make sure the table exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Foreign table ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="foreign_tables_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'foreign tables', _extras('f', $1, $2), _missing('f', $1, $2),
        'Schema ' || quote_ident($1) || ' should have the correct foreign tables'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="foreign_tables_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'foreign tables', _extras('f', $1, $2), _missing('f', $1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="foreign_tables_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'foreign tables', _extras('f', $1), _missing('f', $1),
        'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct foreign tables'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="foreign_tables_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'foreign tables', _extras('f', $1), _missing('f', $1), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_lang_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_lang_is(
        $1, $2,
        'Function ' || quote_ident($1)
        || '() should be written in ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_lang_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_lang_is(
        $1, $2, $3,
        'Function ' || quote_ident($1) || '.' || quote_ident($2)
        || '() should be written in ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_lang_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _lang($1, $2), $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_lang_is(name, name, name[], name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_lang_is(
        $1, $2, $3, $4,
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be written in ' || quote_ident($4)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_lang_is(name, name, name[], name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _lang($1, $2, $3), $4, $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_lang_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _lang($1), $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_lang_is(name, name[], name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_lang_is(
        $1, $2, $3,
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be written in ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_lang_is(name, name[], name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, _lang($1, $2), $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_owner_is(name, name, name[], name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_owner_is(
        $1, $2, $3, $4,
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be owned by ' || quote_ident($4)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_owner_is(name, name, name[], name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_func_owner($1, $2, $3);
BEGIN
    -- Make sure the function exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            E'    Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
                    array_to_string($3, ', ') || ') does not exist'
        );
    END IF;

    RETURN is(owner, $4, $5);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_owner_is(name, name[], name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_owner_is(
        $1, $2, $3,
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_owner_is(name, name[], name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_func_owner($1, $2);
BEGIN
    -- Make sure the function exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Function ' || quote_ident($1) || '(' ||
                    array_to_string($2, ', ') || ') does not exist'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_privs_are(name, name, name[], name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_privs_are(
        $1, $2, $3, $4, $5,
        'Role ' || quote_ident($4) || ' should be granted '
            || CASE WHEN $5[1] IS NULL THEN 'no privileges' ELSE array_to_string($5, ', ') END
            || ' on function ' || quote_ident($1) || '.' || quote_ident($2)
            || '(' || array_to_string($3, ', ') || ')'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_privs_are(name, name, name[], name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _fprivs_are(
        quote_ident($1) || '.' || quote_ident($2) || '(' || array_to_string($3, ', ') || ')',
        $4, $5, $6
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_privs_are(name, name[], name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_privs_are(
        $1, $2, $3, $4,
        'Role ' || quote_ident($3) || ' should be granted '
            || CASE WHEN $4[1] IS NULL THEN 'no privileges' ELSE array_to_string($4, ', ') END
            || ' on function ' || quote_ident($1) || '(' || array_to_string($2, ', ') || ')'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_privs_are(name, name[], name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _fprivs_are(
        quote_ident($1) || '(' || array_to_string($2, ', ') || ')',
        $3, $4, $5
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_returns(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_returns(
        $1, $2, $3, $4,
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should return ' || $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_returns(name, name, name[], text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _returns($1, $2, $3), $4, $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_returns(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_returns(
        $1, $2, $3,
        'Function ' || quote_ident($1) || '.' || quote_ident($2)
        || '() should return ' || $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_returns(name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _returns($1, $2), $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_returns(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_returns(
        $1, $2, $3,
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should return ' || $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_returns(name, name[], text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, _returns($1, $2), $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_returns(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT function_returns(
        $1, $2,
        'Function ' || quote_ident($1) || '() should return ' || $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="function_returns(name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _returns($1), $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="functions_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT functions_are( $1, $2, 'Schema ' || quote_ident($1) || ' should have the correct functions' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="functions_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'functions',
        ARRAY(
            SELECT name FROM tap_funky WHERE schema = $1
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
               FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT name FROM tap_funky WHERE schema = $1
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="functions_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT functions_are( $1, 'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct functions' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="functions_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'functions',
        ARRAY(
            SELECT name FROM tap_funky WHERE is_visible
            AND schema NOT IN ('pg_catalog', 'information_schema')
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
               FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT name FROM tap_funky WHERE is_visible
            AND schema NOT IN ('pg_catalog', 'information_schema')
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bit_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bit_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bit_consistent(internal, bit, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bit_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="bit"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bit_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bit_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bit_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bit_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bit_same(gbtreekey_var, gbtreekey_var, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bit_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey_var"/>
            <parameter mode="IN" type="gbtreekey_var"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bit_union(internal, internal)" returnType="gbtreekey_var" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bit_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bool_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bool_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bool_consistent(internal, boolean, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bool_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bool_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bool_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bool_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bool_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bool_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bool_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bool_same(gbtreekey2, gbtreekey2, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bool_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey2"/>
            <parameter mode="IN" type="gbtreekey2"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bool_union(internal, internal)" returnType="gbtreekey2" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bool_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bpchar_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bpchar_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bpchar_consistent(internal, character, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bpchar_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bytea_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bytea_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bytea_consistent(internal, bytea, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bytea_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bytea_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bytea_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bytea_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bytea_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bytea_same(gbtreekey_var, gbtreekey_var, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bytea_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey_var"/>
            <parameter mode="IN" type="gbtreekey_var"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_bytea_union(internal, internal)" returnType="gbtreekey_var" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_bytea_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_cash_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_cash_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_cash_consistent(internal, money, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_cash_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="money"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_cash_distance(internal, money, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_cash_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="money"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_cash_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_cash_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_cash_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_cash_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_cash_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_cash_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_cash_same(gbtreekey16, gbtreekey16, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_cash_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_cash_union(internal, internal)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_cash_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_date_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_date_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_date_consistent(internal, date, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_date_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="date"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_date_distance(internal, date, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_date_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="date"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_date_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_date_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_date_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_date_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_date_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_date_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_date_same(gbtreekey8, gbtreekey8, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_date_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_date_union(internal, internal)" returnType="gbtreekey8" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_date_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_decompress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_decompress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_enum_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_enum_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_enum_consistent(internal, anyenum, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_enum_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyenum"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_enum_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_enum_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_enum_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_enum_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_enum_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_enum_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_enum_same(gbtreekey8, gbtreekey8, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_enum_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_enum_union(internal, internal)" returnType="gbtreekey8" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_enum_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float4_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float4_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float4_consistent(internal, real, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float4_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="real"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float4_distance(internal, real, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float4_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="real"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float4_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float4_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float4_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float4_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float4_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float4_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float4_same(gbtreekey8, gbtreekey8, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float4_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float4_union(internal, internal)" returnType="gbtreekey8" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float4_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float8_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float8_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float8_consistent(internal, double precision, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float8_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float8_distance(internal, double precision, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float8_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float8_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float8_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float8_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float8_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float8_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float8_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float8_same(gbtreekey16, gbtreekey16, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float8_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_float8_union(internal, internal)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_float8_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_inet_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_inet_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_inet_consistent(internal, inet, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_inet_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="inet"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_inet_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_inet_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_inet_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_inet_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_inet_same(gbtreekey16, gbtreekey16, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_inet_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_inet_union(internal, internal)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_inet_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int2_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int2_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int2_consistent(internal, smallint, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int2_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int2_distance(internal, smallint, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int2_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int2_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int2_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int2_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int2_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int2_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int2_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int2_same(gbtreekey4, gbtreekey4, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int2_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey4"/>
            <parameter mode="IN" type="gbtreekey4"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int2_union(internal, internal)" returnType="gbtreekey4" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int2_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int4_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int4_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int4_consistent(internal, integer, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int4_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int4_distance(internal, integer, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int4_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int4_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int4_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int4_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int4_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int4_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int4_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int4_same(gbtreekey8, gbtreekey8, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int4_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int4_union(internal, internal)" returnType="gbtreekey8" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int4_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int8_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int8_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int8_consistent(internal, bigint, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int8_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="bigint"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int8_distance(internal, bigint, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int8_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="bigint"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int8_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int8_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int8_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int8_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int8_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int8_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int8_same(gbtreekey16, gbtreekey16, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int8_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_int8_union(internal, internal)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_int8_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_consistent(internal, interval, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="interval"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_decompress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_decompress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_distance(internal, interval, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="interval"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_same(gbtreekey32, gbtreekey32, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey32"/>
            <parameter mode="IN" type="gbtreekey32"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_intv_union(internal, internal)" returnType="gbtreekey32" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_intv_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad8_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad8_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad8_consistent(internal, macaddr8, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad8_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="macaddr8"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad8_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad8_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad8_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad8_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad8_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad8_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad8_same(gbtreekey16, gbtreekey16, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad8_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad8_union(internal, internal)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad8_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad_consistent(internal, macaddr, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="macaddr"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad_same(gbtreekey16, gbtreekey16, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_macad_union(internal, internal)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_macad_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_numeric_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_numeric_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_numeric_consistent(internal, numeric, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_numeric_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_numeric_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_numeric_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_numeric_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_numeric_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_numeric_same(gbtreekey_var, gbtreekey_var, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_numeric_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey_var"/>
            <parameter mode="IN" type="gbtreekey_var"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_numeric_union(internal, internal)" returnType="gbtreekey_var" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_numeric_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_oid_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_oid_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_oid_consistent(internal, oid, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_oid_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_oid_distance(internal, oid, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_oid_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_oid_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_oid_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_oid_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_oid_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_oid_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_oid_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_oid_same(gbtreekey8, gbtreekey8, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_oid_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="gbtreekey8"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_oid_union(internal, internal)" returnType="gbtreekey8" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_oid_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_text_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_text_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_text_consistent(internal, text, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_text_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_text_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_text_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_text_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_text_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_text_same(gbtreekey_var, gbtreekey_var, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_text_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey_var"/>
            <parameter mode="IN" type="gbtreekey_var"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_text_union(internal, internal)" returnType="gbtreekey_var" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_text_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_time_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_time_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_time_consistent(internal, time without time zone, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_time_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="time without time zone"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_time_distance(internal, time without time zone, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_time_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="time without time zone"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_time_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_time_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_time_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_time_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_time_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_time_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_time_same(gbtreekey16, gbtreekey16, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_time_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_time_union(internal, internal)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_time_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_timetz_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_timetz_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_timetz_consistent(internal, time with time zone, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_timetz_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="time with time zone"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_ts_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_ts_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_ts_consistent(internal, timestamp without time zone, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_ts_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="timestamp without time zone"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_ts_distance(internal, timestamp without time zone, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_ts_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="timestamp without time zone"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_ts_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_ts_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_ts_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_ts_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_ts_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_ts_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_ts_same(gbtreekey16, gbtreekey16, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_ts_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="gbtreekey16"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_ts_union(internal, internal)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_ts_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_tstz_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_tstz_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_tstz_consistent(internal, timestamp with time zone, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_tstz_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="timestamp with time zone"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_tstz_distance(internal, timestamp with time zone, smallint, oid, internal)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_tstz_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="timestamp with time zone"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_uuid_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_uuid_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_uuid_consistent(internal, uuid, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_uuid_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="uuid"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_uuid_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_uuid_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_uuid_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_uuid_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_uuid_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_uuid_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_uuid_same(gbtreekey32, gbtreekey32, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_uuid_same]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey32"/>
            <parameter mode="IN" type="gbtreekey32"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_uuid_union(internal, internal)" returnType="gbtreekey32" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_uuid_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_var_decompress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_var_decompress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbt_var_fetch(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbt_var_fetch]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey16_in(cstring)" returnType="gbtreekey16" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey16_out(gbtreekey16)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_out]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey16"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey2_in(cstring)" returnType="gbtreekey2" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey2_out(gbtreekey2)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_out]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey2"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey32_in(cstring)" returnType="gbtreekey32" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey32_out(gbtreekey32)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_out]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey32"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey4_in(cstring)" returnType="gbtreekey4" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey4_out(gbtreekey4)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_out]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey4"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey8_in(cstring)" returnType="gbtreekey8" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey8_out(gbtreekey8)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_out]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey8"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey_var_in(cstring)" returnType="gbtreekey_var" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gbtreekey_var_out(gbtreekey_var)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gbtreekey_out]]></definition>
         <parameters>
            <parameter mode="IN" type="gbtreekey_var"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gen_random_bytes(integer)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_random_bytes]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gen_random_uuid()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_random_uuid]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gen_salt(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_gen_salt]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gen_salt(text, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_gen_salt_rounds]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_consistent(internal, hstore, smallint, oid, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_decompress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_decompress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_in(cstring)" returnType="ghstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_options(internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_options]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_out(ghstore)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_out]]></definition>
         <parameters>
            <parameter mode="IN" type="ghstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_same(ghstore, ghstore, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_same]]></definition>
         <parameters>
            <parameter mode="IN" type="ghstore"/>
            <parameter mode="IN" type="ghstore"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ghstore_union(internal, internal)" returnType="ghstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ghstore_union]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gin_consistent_hstore(internal, smallint, hstore, integer, internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gin_consistent_hstore]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gin_extract_hstore(hstore, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gin_extract_hstore]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gin_extract_hstore_query(hstore, internal, smallint, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gin_extract_hstore_query]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="groups_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT groups_are( $1, 'There should be the correct groups' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="groups_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'groups',
        ARRAY(
            SELECT groname
              FROM pg_catalog.pg_group
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT groname
              FROM pg_catalog.pg_group
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_cast(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _cast_exists( $1, $2 ),
        'Cast (' || quote_ident($1) || ' AS ' || quote_ident($2)
        || ') should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_cast(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _cast_exists( $1, $2, $3 ),
        'Cast (' || quote_ident($1) || ' AS ' || quote_ident($2)
        || ') WITH FUNCTION ' || quote_ident($3) || '() should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_cast(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
       _cast_exists( $1, $2, $3, $4 ),
        'Cast (' || quote_ident($1) || ' AS ' || quote_ident($2)
        || ') WITH FUNCTION ' || quote_ident($3)
        || '.' || quote_ident($4) || '() should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_cast(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _cast_exists( $1, $2, $3, $4 ), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_cast(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _cast_exists( $1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_cast(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _cast_exists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_check(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_check( $1, 'Table ' || quote_ident($1) || ' should have a check constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_check(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _hasc( $1, $2, 'c' ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_check(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _hasc( $1, 'c' ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_column(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_column( $1, $2, 'Column ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_column(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _cexists( $1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_column(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _cexists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_composite(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_composite( $1, 'Composite type ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_composite(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'c', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_composite(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'c', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_domain(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, ARRAY['d'] ), ('Domain ' || quote_ident($1) || ' should exist')::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_domain(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_domain( $1, $2, 'Domain ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_domain(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, $2, ARRAY['d'] ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_domain(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, ARRAY['d'] ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_enum(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, ARRAY['e'] ), ('Enum ' || quote_ident($1) || ' should exist')::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_enum(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_enum( $1, $2, 'Enum ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_enum(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, $2, ARRAY['e'] ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_enum(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, ARRAY['e'] ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_extension(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ext_exists( $1 ),
        'Extension ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_extension(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ext_exists( $1, $2 ),
        'Extension ' || quote_ident($2)
        || ' should exist in schema ' || quote_ident($1) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_extension(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ext_exists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_extension(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ext_exists( $1 ), $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_fk(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_fk( $1, 'Table ' || quote_ident($1) || ' should have a foreign key constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_fk(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _hasc( $1, $2, 'f' ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_fk(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _hasc( $1, 'f' ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_foreign_table(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_foreign_table( $1, 'Foreign table ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_foreign_table(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _rexists( 'f', $1, $2 ),
        'Foreign table ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_foreign_table(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'f', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_foreign_table(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'f', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_function(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _got_func($1), 'Function ' || quote_ident($1) || '() should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_function(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _got_func($1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_function(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _got_func($1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_function(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _got_func($1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_function(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _got_func($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_function(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _got_func($1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_function(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _got_func($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_function(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _got_func($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_group(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_group($1), 'Group ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_group(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_group($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _have_index( $1, $2 ), 'Index ' || quote_ident($2) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
   IF _is_schema($1) THEN
       -- ( schema, table, index )
       RETURN ok( _have_index( $1, $2, $3 ), 'Index ' || quote_ident($3) || ' should exist' );
   ELSE
       -- ( table, index, column/expression )
       RETURN has_index( $1, $2, $3, 'Index ' || quote_ident($2) || ' should exist' );
   END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_index( $1, $2, $3, $4, 'Index ' || quote_ident($3) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_index( $1, $2, $3, ARRAY[$4], $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_index( $1, $2, $3, $4, 'Index ' || quote_ident($3) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
     index_cols name[];
BEGIN
    index_cols := _ikeys($1, $2, $3 );

    IF index_cols IS NULL OR index_cols = '{}'::name[] THEN
        RETURN ok( false, $5 ) || E'\n'
            || diag( 'Index ' || quote_ident($3) || ' ON ' || quote_ident($1) || '.' || quote_ident($2) || ' not found');
    END IF;

    RETURN is(
        quote_ident($3) || ' ON ' || quote_ident($1) || '.' || quote_ident($2) || '(' || array_to_string( index_cols, ', ' ) || ')',
        quote_ident($3) || ' ON ' || quote_ident($1) || '.' || quote_ident($2) || '(' || array_to_string( $4, ', ' ) || ')',
        $5
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN _is_schema( $1 ) THEN
        -- Looking for schema.table index.
            ok ( _have_index( $1, $2, $3 ), $4)
        ELSE
        -- Looking for particular columns.
            has_index( $1, $2, ARRAY[$3], $4 )
      END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_index( $1, $2, $3, 'Index ' || quote_ident($2) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
     index_cols name[];
BEGIN
    index_cols := _ikeys($1, $2 );

    IF index_cols IS NULL OR index_cols = '{}'::name[] THEN
        RETURN ok( false, $4 ) || E'\n'
            || diag( 'Index ' || quote_ident($2) || ' ON ' || quote_ident($1) || ' not found');
    END IF;

    RETURN is(
        quote_ident($2) || ' ON ' || quote_ident($1) || '(' || array_to_string( index_cols, ', ' ) || ')',
        quote_ident($2) || ' ON ' || quote_ident($1) || '(' || array_to_string( $3, ', ' ) || ')',
        $4
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_index(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN $3 LIKE '%(%'
           THEN has_index( $1, $2, $3::name )
           ELSE ok( _have_index( $1, $2 ), $3 )
           END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_inherited_tables(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _inherited( $1 ),
        'Table ' || quote_ident( $1 ) || ' should have descendents'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_inherited_tables(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _inherited( $1, $2 ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 ) || ' should have descendents'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_inherited_tables(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _inherited( $1, $2 ), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_inherited_tables(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _inherited( $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_language(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_trusted($1) IS NOT NULL, 'Procedural language ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_language(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_trusted($1) IS NOT NULL, $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_leftop(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists(NULL, $1, $2 ),
        'Left operator ' || $1 || '(NONE,' || $2 || ') should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_leftop(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists(NULL, $1, $2, $3 ),
        'Left operator ' || $1 || '(NONE,' || $2 || ') RETURNS ' || $3 || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_leftop(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists(NULL, $1, $2, $3, $4 ),
        'Left operator ' || quote_ident($1) || '.' || $2 || '(NONE,'
        || $3 || ') RETURNS ' || $4 || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_leftop(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists(NULL, $1, $2, $3, $4), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_leftop(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists(NULL, $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_leftop(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists(NULL, $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_materialized_view(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_materialized_view( $1, 'Materialized view ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_materialized_view(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'm', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_materialized_view(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'm', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_opclass(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _opc_exists( $1 ), 'Operator class ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_opclass(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _opc_exists( $1, $2 ), 'Operator class ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_opclass(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _opc_exists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_opclass(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _opc_exists( $1 ), $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_operator(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists($1, $2, $3 ),
        'Operator ' ||  $2 || '(' || $1 || ',' || $3
        || ') should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_operator(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists($1, $2, $3, $4 ),
        'Operator ' ||  $2 || '(' || $1 || ',' || $3
        || ') RETURNS ' || $4 || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_operator(name, name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists($1, $2, $3, $4, $5 ),
        'Operator ' || quote_ident($2) || '.' || $3 || '(' || $1 || ',' || $4
        || ') RETURNS ' || $5 || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_operator(name, name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists($1, $2, $3, $4, $5 ), $6 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_operator(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists($1, $2, $3, $4 ), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_operator(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists($1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_pk(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_pk( $1, 'Table ' || quote_ident($1) || ' should have a primary key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_pk(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _hasc( $1, $2, 'p' ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_pk(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _hasc( $1, 'p' ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_relation(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_relation( $1, 'Relation ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_relation(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _relexists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_relation(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _relexists( $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rightop(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists($1, $2, NULL ),
        'Right operator ' || $2 || '(' || $1 || ',NONE) should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rightop(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists($1, $2, NULL, $3 ),
        'Right operator ' || $2 || '('
        || $1 || ',NONE) RETURNS ' || $3 || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rightop(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         _op_exists($1, $2, $3, NULL, $4 ),
        'Right operator ' || quote_ident($2) || '.' || $3 || '('
        || $1 || ',NONE) RETURNS ' || $4 || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rightop(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists( $1, $2, $3, NULL, $4), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rightop(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists( $1, $2, NULL, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rightop(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _op_exists( $1, $2, NULL), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_role(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_role($1), 'Role ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_role(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_role($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rule(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_instead($1, $2) IS NOT NULL, 'Relation ' || quote_ident($1) || ' should have rule ' || quote_ident($2) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rule(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_instead($1, $2, $3) IS NOT NULL, 'Relation ' || quote_ident($1) || '.' || quote_ident($2) || ' should have rule ' || quote_ident($3) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rule(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_instead($1, $2, $3) IS NOT NULL, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_rule(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_instead($1, $2) IS NOT NULL, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_schema(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_schema( $1, 'Schema ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_schema(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        EXISTS(
            SELECT true
              FROM pg_catalog.pg_namespace
             WHERE nspname = $1
        ), $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_sequence(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_sequence( $1, 'Sequence ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_sequence(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _rexists( 'S', $1, $2 ),
        'Sequence ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_sequence(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'S', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_sequence(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'S', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_table(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_table( $1, 'Table ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_table(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _rexists( '{r,p}'::char[], $1, $2 ),
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_table(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( '{r,p}'::char[], $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_table(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( '{r,p}'::char[], $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_tablespace(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_tablespace( $1, 'Tablespace ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_tablespace(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        EXISTS(
            SELECT true
              FROM pg_catalog.pg_tablespace
             WHERE spcname = $1
        ), $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_tablespace(name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF pg_version_num() >= 90200 THEN
        RETURN ok(
            EXISTS(
                SELECT true
                  FROM pg_catalog.pg_tablespace
                 WHERE spcname = $1
                   AND pg_tablespace_location(oid) = $2
            ), $3
        );
    ELSE
        RETURN ok(
            EXISTS(
                SELECT true
                  FROM pg_catalog.pg_tablespace
                 WHERE spcname = $1
                   AND spclocation = $2
            ), $3
        );
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_trigger(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _trig($1, $2), 'Table ' || quote_ident($1) || ' should have trigger ' || quote_ident($2));]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_trigger(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_trigger(
        $1, $2, $3,
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should have trigger ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_trigger(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _trig($1, $2, $3), $4);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_trigger(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _trig($1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_type(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, NULL ), ('Type ' || quote_ident($1) || ' should exist')::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_type(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_type( $1, $2, 'Type ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_type(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, $2, NULL ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_type(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_type( $1, NULL ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_unique(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_unique( $1, 'Table ' || quote_ident($1) || ' should have a unique constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_unique(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _hasc( $1, 'u' ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_unique(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _hasc( $1, $2, 'u' ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_user(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_user( $1 ), 'User ' || quote_ident($1) || ' should exist');]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_user(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _has_user($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_view(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_view( $1, 'View ' || quote_ident($1) || ' should exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_view(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT has_view (
        $1, $2,
        'View ' || quote_ident($1) || '.' || quote_ident($2) || ' should exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_view(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'v', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="has_view(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists( 'v', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_cast(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _cast_exists( $1, $2 ),
        'Cast (' || quote_ident($1) || ' AS ' || quote_ident($2)
        || ') should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_cast(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _cast_exists( $1, $2, $3 ),
        'Cast (' || quote_ident($1) || ' AS ' || quote_ident($2)
        || ') WITH FUNCTION ' || quote_ident($3) || '() should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_cast(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
       NOT _cast_exists( $1, $2, $3, $4 ),
        'Cast (' || quote_ident($1) || ' AS ' || quote_ident($2)
        || ') WITH FUNCTION ' || quote_ident($3)
        || '.' || quote_ident($4) || '() should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_cast(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _cast_exists( $1, $2, $3, $4 ), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_cast(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _cast_exists( $1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_cast(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _cast_exists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_column(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_column( $1, $2, 'Column ' || quote_ident($1) || '.' || quote_ident($2) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_column(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _cexists( $1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_column(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _cexists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_composite(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_composite( $1, 'Composite type ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_composite(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'c', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_composite(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'c', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_domain(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, ARRAY['d'] ), ('Domain ' || quote_ident($1) || ' should not exist')::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_domain(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_domain( $1, $2, 'Domain ' || quote_ident($1) || '.' || quote_ident($2) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_domain(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, $2, ARRAY['d'] ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_domain(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, ARRAY['d'] ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_enum(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, ARRAY['e'] ), ('Enum ' || quote_ident($1) || ' should not exist')::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_enum(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_enum( $1, $2, 'Enum ' || quote_ident($1) || '.' || quote_ident($2) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_enum(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, $2, ARRAY['e'] ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_enum(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, ARRAY['e'] ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_extension(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _ext_exists( $1 ),
        'Extension ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_extension(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _ext_exists( $1, $2 ),
        'Extension ' || quote_ident($2)
        || ' should not exist in schema ' || quote_ident($1) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_extension(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _ext_exists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_extension(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _ext_exists( $1 ), $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_fk(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_fk( $1, 'Table ' || quote_ident($1) || ' should not have a foreign key constraint' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_fk(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _hasc( $1, $2, 'f' ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_fk(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _hasc( $1, 'f' ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_foreign_table(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_foreign_table( $1, 'Foreign table ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_foreign_table(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _rexists( 'f', $1, $2 ),
        'Foreign table ' || quote_ident($1) || '.' || quote_ident($2) || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_foreign_table(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'f', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_foreign_table(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'f', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_function(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _got_func($1), 'Function ' || quote_ident($1) || '() should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_function(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _got_func($1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_function(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _got_func($1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_function(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _got_func($1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_function(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _got_func($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_function(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _got_func($1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_function(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _got_func($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_function(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _got_func($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_group(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_group($1), 'Group ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_group(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_group($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_index(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _have_index( $1, $2 ),
        'Index ' || quote_ident($2) || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_index(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _have_index( $1, $2, $3 ),
        'Index ' || quote_ident($3) || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_index(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    RETURN ok( NOT _have_index( $1, $2, $3 ), $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_index(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _have_index( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_inherited_tables(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _inherited( $1 ),
        'Table ' || quote_ident( $1 ) || ' should not have descendents'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_inherited_tables(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _inherited( $1, $2 ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 ) || ' should not have descendents'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_inherited_tables(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _inherited( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_inherited_tables(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _inherited( $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_language(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_trusted($1) IS NULL, 'Procedural language ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_language(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_trusted($1) IS NULL, $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_leftop(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists(NULL, $1, $2 ),
        'Left operator ' || $1 || '(NONE,' || $2 || ') should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_leftop(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists(NULL, $1, $2, $3 ),
        'Left operator ' || $1 || '(NONE,' || $2 || ') RETURNS ' || $3 || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_leftop(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists(NULL, $1, $2, $3, $4 ),
        'Left operator ' || quote_ident($1) || '.' || $2 || '(NONE,'
        || $3 || ') RETURNS ' || $4 || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_leftop(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists(NULL, $1, $2, $3, $4), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_leftop(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists(NULL, $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_leftop(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists(NULL, $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_materialized_view(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_materialized_view( $1, 'Materialized view ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_materialized_view(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'm', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_materialized_view(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'm', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_opclass(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _opc_exists( $1 ), 'Operator class ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_opclass(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _opc_exists( $1, $2 ), 'Operator class ' || quote_ident($1) || '.' || quote_ident($2) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_opclass(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _opc_exists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_opclass(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _opc_exists( $1 ), $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_operator(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists($1, $2, $3 ),
        'Operator ' ||  $2 || '(' || $1 || ',' || $3
        || ') should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_operator(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists($1, $2, $3, $4 ),
        'Operator ' ||  $2 || '(' || $1 || ',' || $3
        || ') RETURNS ' || $4 || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_operator(name, name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists($1, $2, $3, $4, $5 ),
        'Operator ' || quote_ident($2) || '.' || $3 || '(' || $1 || ',' || $4
        || ') RETURNS ' || $5 || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_operator(name, name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists($1, $2, $3, $4, $5 ), $6 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_operator(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists($1, $2, $3, $4 ), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_operator(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists($1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_pk(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_pk( $1, 'Table ' || quote_ident($1) || ' should not have a primary key' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_pk(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _hasc( $1, $2, 'p' ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_pk(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _hasc( $1, 'p' ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_relation(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_relation( $1, 'Relation ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_relation(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _relexists( $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_relation(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _relexists( $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rightop(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists($1, $2, NULL ),
        'Right operator ' || $2 || '(' || $1 || ',NONE) should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rightop(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists($1, $2, NULL, $3 ),
        'Right operator ' || $2 || '('
        || $1 || ',NONE) RETURNS ' || $3 || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rightop(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
         NOT _op_exists($1, $2, $3, NULL, $4 ),
        'Right operator ' || quote_ident($2) || '.' || $3 || '('
        || $1 || ',NONE) RETURNS ' || $4 || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rightop(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists( $1, $2, $3, NULL, $4), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rightop(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists( $1, $2, NULL, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rightop(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _op_exists( $1, $2, NULL), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_role(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_role($1), 'Role ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_role(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_role($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rule(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_instead($1, $2) IS NULL, 'Relation ' || quote_ident($1) || ' should not have rule ' || quote_ident($2) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rule(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_instead($1, $2, $3) IS NULL, 'Relation ' || quote_ident($1) || '.' || quote_ident($2) || ' should not have rule ' || quote_ident($3) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rule(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_instead($1, $2, $3) IS NULL, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_rule(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_instead($1, $2) IS NULL, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_schema(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_schema( $1, 'Schema ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_schema(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT EXISTS(
            SELECT true
              FROM pg_catalog.pg_namespace
             WHERE nspname = $1
        ), $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_sequence(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_sequence( $1, 'Sequence ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_sequence(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'S', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_sequence(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'S', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_table(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_table( $1, 'Table ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_table(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _rexists( '{r,p}'::char[], $1, $2 ),
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_table(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( '{r,p}'::char[], $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_table(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( '{r,p}'::char[], $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_tablespace(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_tablespace( $1, 'Tablespace ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_tablespace(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT EXISTS(
            SELECT true
              FROM pg_catalog.pg_tablespace
             WHERE spcname = $1
        ), $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_trigger(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _trig($1, $2), 'Table ' || quote_ident($1) || ' should not have trigger ' || quote_ident($2));]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_trigger(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _trig($1, $2, $3),
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should not have trigger ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_trigger(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _trig($1, $2, $3), $4);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_trigger(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _trig($1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_type(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, NULL ), ('Type ' || quote_ident($1) || ' should not exist')::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_type(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_type( $1, $2, 'Type ' || quote_ident($1) || '.' || quote_ident($2) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_type(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, $2, NULL ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_type(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_type( $1, NULL ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_user(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_user( $1 ), 'User ' || quote_ident($1) || ' should not exist');]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_user(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _has_user($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_view(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_view( $1, 'View ' || quote_ident($1) || ' should not exist' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_view(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT hasnt_view( $1, $2,
        'View ' || quote_ident($1) || '.' || quote_ident($2) || ' should not exist'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_view(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'v', $1, $2 ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hasnt_view(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists( 'v', $1 ), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hmac(bytea, bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_hmac]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hmac(text, text, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pg_hmac]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hs_concat(hstore, hstore)" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_concat]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hs_contained(hstore, hstore)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_contained]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hs_contains(hstore, hstore)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_contains]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore(record)" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_from_record]]></definition>
         <parameters>
            <parameter mode="IN" type="record"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore(text, text)" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore(text[])" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_from_array]]></definition>
         <parameters>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore(text[], text[])" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_from_arrays]]></definition>
         <parameters>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_cmp(hstore, hstore)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_cmp]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_eq(hstore, hstore)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_eq]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_ge(hstore, hstore)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_ge]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_gt(hstore, hstore)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_gt]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_hash(hstore)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_hash]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_hash_extended(hstore, bigint)" returnType="bigint" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_hash_extended]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="bigint"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_in(cstring)" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_le(hstore, hstore)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_le]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_lt(hstore, hstore)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_lt]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_ne(hstore, hstore)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_ne]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_out(hstore)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_out]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_recv(internal)" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_recv]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_send(hstore)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_send]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_subscript_handler(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_subscript_handler]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_to_array(hstore)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_to_array]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_to_json(hstore)" returnType="json" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_to_json]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_to_json_loose(hstore)" returnType="json" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_to_json_loose]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_to_jsonb(hstore)" returnType="jsonb" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_to_jsonb]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_to_jsonb_loose(hstore)" returnType="jsonb" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_to_jsonb_loose]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_to_matrix(hstore)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_to_matrix]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hstore_version_diag(hstore)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_version_diag]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="ialike(anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _alike( $1 ~~* $2, $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="ialike(anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _alike( $1 ~~* $2, $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="imatches(anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _alike( $1 ~* $2, $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="imatches(anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _alike( $1 ~* $2, $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="in_todo()" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    todos integer;
BEGIN
    todos := _get('todo');
    RETURN CASE WHEN todos IS NULL THEN FALSE ELSE TRUE END;
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_primary(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisprimary
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_class ct ON ct.oid = x.indrelid
     WHERE ci.relname = $1
       AND pg_catalog.pg_table_is_visible(ct.oid)
      INTO res;

      RETURN ok(
          COALESCE(res, false),
          'Index ' || quote_ident($1) || ' should be on a primary key'
      );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_primary(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisprimary
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
     WHERE ct.relname = $1
       AND ci.relname = $2
       AND pg_catalog.pg_table_is_visible(ct.oid)
     INTO res;

      RETURN ok(
          COALESCE(res, false),
          'Index ' || quote_ident($2) || ' should be on a primary key'
      );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_primary(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT index_is_primary(
        $1, $2, $3,
        'Index ' || quote_ident($3) || ' should be on a primary key'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_primary(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisprimary
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
     WHERE ct.relname = $2
       AND ci.relname = $3
       AND n.nspname  = $1
      INTO res;

      RETURN ok( COALESCE(res, false), $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_type(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    aname name;
BEGIN
    SELECT am.amname
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_am am    ON ci.relam = am.oid
     WHERE ci.relname = $1
      INTO aname;

      return is(
          aname, $2,
          'Index ' || quote_ident($1) || ' should be a ' || quote_ident($2) || ' index'
      );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_type(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    aname name;
BEGIN
    SELECT am.amname
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_am am    ON ci.relam = am.oid
     WHERE ct.relname = $1
       AND ci.relname = $2
      INTO aname;

      return is(
          aname, $3,
          'Index ' || quote_ident($2) || ' should be a ' || quote_ident($3) || ' index'
      );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_type(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT index_is_type(
        $1, $2, $3, $4,
        'Index ' || quote_ident($3) || ' should be a ' || quote_ident($4) || ' index'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_type(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    aname name;
BEGIN
    SELECT am.amname
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
      JOIN pg_catalog.pg_am am       ON ci.relam = am.oid
     WHERE ct.relname = $2
       AND ci.relname = $3
       AND n.nspname  = $1
      INTO aname;

      return is( aname, $4, $5 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_unique(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisunique
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_class ct ON ct.oid = x.indrelid
     WHERE ci.relname = $1
       AND pg_catalog.pg_table_is_visible(ct.oid)
      INTO res;

      RETURN ok(
          COALESCE(res, false),
          'Index ' || quote_ident($1) || ' should be unique'
      );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_unique(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisunique
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
     WHERE ct.relname = $1
       AND ci.relname = $2
       AND pg_catalog.pg_table_is_visible(ct.oid)
      INTO res;

      RETURN ok(
          COALESCE(res, false),
          'Index ' || quote_ident($2) || ' should be unique'
      );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_unique(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT index_is_unique(
        $1, $2, $3,
        'Index ' || quote_ident($3) || ' should be unique'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_is_unique(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisunique
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
     WHERE ct.relname = $2
       AND ci.relname = $3
       AND n.nspname  = $1
      INTO res;

      RETURN ok( COALESCE(res, false), $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT index_owner_is(
        $1, $2, $3,
        'Index ' || quote_ident($2) || ' ON '
        || quote_ident($1) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_owner_is(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT index_owner_is(
        $1, $2, $3, $4,
        'Index ' || quote_ident($3) || ' ON '
        || quote_ident($1) || '.' || quote_ident($2)
        || ' should be owned by ' || quote_ident($4)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_owner_is(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_index_owner($1, $2, $3);
BEGIN
    -- Make sure the index exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            E'    Index ' || quote_ident($3) || ' ON '
            || quote_ident($1) || '.' || quote_ident($2) || ' not found'
        );
    END IF;

    RETURN is(owner, $4, $5);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="index_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_index_owner($1, $2);
BEGIN
    -- Make sure the index exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Index ' || quote_ident($2) || ' ON ' || quote_ident($1) || ' not found'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="indexes_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT indexes_are( $1, $2, $3, 'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should have the correct indexes' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="indexes_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'indexes',
        ARRAY(
            SELECT ci.relname
              FROM pg_catalog.pg_index x
              JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
              JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
             WHERE ct.relname = $2
               AND n.nspname  = $1
            EXCEPT
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
        ),
        ARRAY(
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
            EXCEPT
            SELECT ci.relname
              FROM pg_catalog.pg_index x
              JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
              JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
             WHERE ct.relname = $2
               AND n.nspname  = $1
        ),
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="indexes_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT indexes_are( $1, $2, 'Table ' || quote_ident($1) || ' should have the correct indexes' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="indexes_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'indexes',
        ARRAY(
            SELECT ci.relname
              FROM pg_catalog.pg_index x
              JOIN pg_catalog.pg_class ct ON ct.oid = x.indrelid
              JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
             WHERE ct.relname = $1
               AND pg_catalog.pg_table_is_visible(ct.oid)
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT ci.relname
              FROM pg_catalog.pg_index x
              JOIN pg_catalog.pg_class ct ON ct.oid = x.indrelid
              JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
             WHERE ct.relname = $1
               AND pg_catalog.pg_table_is_visible(ct.oid)
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="int2_dist(smallint, smallint)" returnType="smallint" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[int2_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="smallint"/>
            <parameter mode="IN" type="smallint"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="int4_dist(integer, integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[int4_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="int8_dist(bigint, bigint)" returnType="bigint" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[int8_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="bigint"/>
            <parameter mode="IN" type="bigint"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="interval_dist(interval, interval)" returnType="interval" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[interval_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="interval"/>
            <parameter mode="IN" type="interval"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is(anyelement, anyelement)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is( $1, $2, NULL);]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is(anyelement, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    result BOOLEAN;
    output TEXT;
BEGIN
    -- Would prefer $1 IS NOT DISTINCT FROM, but that's not supported by 8.1.
    result := NOT $1 IS DISTINCT FROM $2;
    output := ok( result, $3 );
    RETURN output || CASE result WHEN TRUE THEN '' ELSE E'\n' || diag(
           '        have: ' || CASE WHEN $1 IS NULL THEN 'NULL' ELSE $1::text END ||
        E'\n        want: ' || CASE WHEN $2 IS NULL THEN 'NULL' ELSE $2::text END
    ) END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_aggregate(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1,  _type_func('a', $1),
        'Function ' || quote_ident($1) || '() should be an aggregate function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_aggregate(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, _type_func('a', $1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should be an aggregate function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_aggregate(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, $3, _type_func('a', $1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be an aggregate function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_aggregate(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _type_func( 'a', $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_aggregate(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _type_func('a', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_aggregate(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, $2, _type_func('a', $1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be an aggregate function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_aggregate(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare( NULL, $1, $2, _type_func('a', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_aggregate(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _type_func('a', $1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_ancestor_of(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ancestor_of( $1, $2, NULL ),
        'Table ' || quote_ident( $1 ) || ' should be an ancestor of ' || quote_ident( $2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_ancestor_of(name, name, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ancestor_of( $1, $2, $3 ),
        'Table ' || quote_ident( $1 ) || ' should be ancestor ' || $3 || ' of ' || quote_ident( $2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_ancestor_of(name, name, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ancestor_of( $1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_ancestor_of(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ancestor_of( $1, $2, $3, $4, NULL ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 )
        || ' should be an ancestor of '
        || quote_ident( $3 ) || '.' || quote_ident( $4 )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_ancestor_of(name, name, name, name, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ancestor_of( $1, $2, $3, $4, $5 ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 )
        || ' should be ancestor ' || $5 || ' for '
        || quote_ident( $3 ) || '.' || quote_ident( $4 )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_ancestor_of(name, name, name, name, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ancestor_of( $1, $2, $3, $4, $5 ), $6 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_ancestor_of(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ancestor_of( $1, $2, $3, $4, NULL ), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_ancestor_of(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ancestor_of( $1, $2, NULL ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_clustered(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisclustered
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
     WHERE ci.relname = $1
      INTO res;

      RETURN ok(
          COALESCE(res, false),
          'Table should be clustered on index ' || quote_ident($1)
      );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_clustered(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisclustered
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci ON ci.oid = x.indexrelid
     WHERE ct.relname = $1
       AND ci.relname = $2
      INTO res;

      RETURN ok(
          COALESCE(res, false),
          'Table ' || quote_ident($1) || ' should be clustered on index ' || quote_ident($2)
      );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_clustered(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_clustered(
        $1, $2, $3,
        'Table ' || quote_ident($1) || '.' || quote_ident($2) ||
        ' should be clustered on index ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_clustered(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res boolean;
BEGIN
    SELECT x.indisclustered
      FROM pg_catalog.pg_index x
      JOIN pg_catalog.pg_class ct    ON ct.oid = x.indrelid
      JOIN pg_catalog.pg_class ci    ON ci.oid = x.indexrelid
      JOIN pg_catalog.pg_namespace n ON n.oid = ct.relnamespace
     WHERE ct.relname = $2
       AND ci.relname = $3
       AND n.nspname  = $1
      INTO res;

      RETURN ok( COALESCE(res, false), $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_definer(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _definer($1), 'Function ' || quote_ident($1) || '() should be security definer' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_definer(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _definer($1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should be security definer'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_definer(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _definer($1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be security definer'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_definer(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _definer($1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_definer(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _definer($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_definer(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _definer($1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be security definer'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_definer(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, _definer($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_definer(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _definer($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_descendent_of(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ancestor_of( $2, $1, NULL ),
        'Table ' || quote_ident( $1 ) || ' should be a descendent of ' || quote_ident( $2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_descendent_of(name, name, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ancestor_of( $2, $1, $3 ),
        'Table ' || quote_ident( $1 ) || ' should be descendent ' || $3 || ' from ' || quote_ident( $2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_descendent_of(name, name, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ancestor_of( $2, $1, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_descendent_of(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ancestor_of( $3, $4, $1, $2, NULL ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 )
        || ' should be a descendent of '
        || quote_ident( $3 ) || '.' || quote_ident( $4 )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_descendent_of(name, name, name, name, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _ancestor_of( $3, $4, $1, $2, $5 ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 )
        || ' should be descendent ' || $5 || ' from '
        || quote_ident( $3 ) || '.' || quote_ident( $4 )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_descendent_of(name, name, name, name, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ancestor_of( $3, $4, $1, $2, $5 ), $6 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_descendent_of(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ancestor_of( $3, $4, $1, $2, NULL ), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_descendent_of(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _ancestor_of( $2, $1, NULL ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_empty(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_empty( $1, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_empty(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    extras  TEXT[]  := '{}';
    res     BOOLEAN := TRUE;
    msg     TEXT    := '';
    rec     RECORD;
BEGIN
    -- Find extra records.
    FOR rec in EXECUTE _query($1) LOOP
        extras := extras || rec::text;
    END LOOP;

    -- What extra records do we have?
    IF extras[1] IS NOT NULL THEN
        res := FALSE;
        msg := E'\n' || diag(
            E'    Unexpected records:\n        '
            ||  array_to_string( extras, E'\n        ' )
        );
    END IF;

    RETURN ok(res, $2) || msg;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_indexed(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok ( _is_indexed( NULL, $1, ARRAY[$2]::NAME[]) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_indexed(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN _is_schema( $1 ) THEN
                -- Looking for schema.table index.
                is_indexed( $1, $2, ARRAY[$3]::NAME[] )
           ELSE
                -- Looking for particular columns.
                is_indexed( $1, ARRAY[$2]::NAME[], $3 )
           END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_indexed(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok ( _is_indexed( $1, $2, ARRAY[$3]::NAME[]), $4);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_indexed(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
       _is_indexed($1, $2, $3),
       'Should have an index on ' ||  quote_ident($1) || '.' || quote_ident($2) || '(' || array_to_string( $3, ', ' ) || ')'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_indexed(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_indexed($1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_indexed(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
       _is_indexed(NULL, $1, $2),
       'Should have an index on ' ||  quote_ident($1) || '(' || array_to_string( $2, ', ' ) || ')'
   );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_indexed(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _is_indexed(NULL, $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_member_of(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_member_of( $1, ARRAY[$2] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_member_of(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_member_of( $1, ARRAY[$2], $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_member_of(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_member_of( $1, $2, 'Should have members of role ' || quote_ident($1) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_member_of(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    missing text[];
BEGIN
    IF NOT _has_role($1) THEN
        RETURN fail( $3 ) || E'\n' || diag (
            '    Role ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    SELECT ARRAY(
        SELECT quote_ident($2[i])
          FROM generate_series(1, array_upper($2, 1)) s(i)
          LEFT JOIN pg_catalog.pg_roles r ON rolname = $2[i]
         WHERE r.oid IS NULL
            OR NOT r.oid = ANY ( _grolist($1) )
         ORDER BY s.i
    ) INTO missing;
    IF missing[1] IS NULL THEN
        RETURN ok( true, $3 );
    END IF;
    RETURN ok( false, $3 ) || E'\n' || diag(
        '    Members missing from the ' || quote_ident($1) || E' role:\n        ' ||
        array_to_string( missing, E'\n        ')
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_normal_function(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, _type_func('f', $1),
        'Function ' || quote_ident($1) || '() should be a normal function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_normal_function(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, _type_func('f', $1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should be a normal function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_normal_function(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, $3,
        _type_func('f', $1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be a normal function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_normal_function(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _type_func('f', $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_normal_function(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _type_func('f', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_normal_function(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, $2, _type_func('f', $1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be a normal function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_normal_function(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, _type_func('f', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_normal_function(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _type_func('f', $1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_partition_of(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _partof($1, $2),
        'Table ' || quote_ident($1) || ' should be a partition of ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_partition_of(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _partof($1, $2, $3, $4),
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should be a partition of '
        || quote_ident($3) || '.' || quote_ident($4)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_partition_of(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _partof($1, $2, $3, $4), $5);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_partition_of(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _partof($1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_partitioned(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _rexists('p', $1),
        'Table ' || quote_ident($1) || ' should be partitioned'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_partitioned(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _rexists('p', $1, $2),
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should be partitioned'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_partitioned(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists('p', $1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_partitioned(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _rexists('p', $1), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_procedure(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, _type_func('p', $1),
        'Function ' || quote_ident($1) || '() should be a procedure'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_procedure(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, _type_func('p', $1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should be a procedure'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_procedure(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, $3, _type_func('p', $1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be a procedure'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_procedure(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _type_func( 'p', $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_procedure(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _type_func('p', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_procedure(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, $2, _type_func('p', $1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be a procedure'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_procedure(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, _type_func('p', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_procedure(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _type_func('p', $1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_strict(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( _strict($1), 'Function ' || quote_ident($1) || '() should be strict' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_strict(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _strict($1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should be strict'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_strict(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _strict($1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be strict'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_strict(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _strict($1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_strict(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _strict($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_strict(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        _strict($1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be strict'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_strict(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, _strict($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_strict(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _strict($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_superuser(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT is_superuser( $1, 'User ' || quote_ident($1) || ' should be a super user' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_superuser(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    is_super boolean := _is_super($1);
BEGIN
    IF is_super IS NULL THEN
        RETURN fail( $2 ) || E'\n' || diag( '    User ' || quote_ident($1) || ' does not exist') ;
    END IF;
    RETURN ok( is_super, $2 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_window(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, _type_func('w', $1),
        'Function ' || quote_ident($1) || '() should be a window function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_window(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, _type_func('w', $1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should be a window function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_window(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, $3, _type_func('w', $1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be a window function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_window(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _type_func( 'w', $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_window(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _type_func('w', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_window(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, $2, _type_func('w', $1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be a window function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_window(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, _type_func('w', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="is_window(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _type_func('w', $1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isa_ok(anyelement, regtype)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isa_ok($1, $2, 'the value');]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="regtype"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isa_ok(anyelement, regtype, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    typeof regtype := pg_typeof($1);
BEGIN
    IF typeof = $2 THEN RETURN ok(true, $3 || ' isa ' || $2 ); END IF;
    RETURN ok(false, $3 || ' isa ' || $2 ) || E'\n' ||
        diag('    ' || $3 || ' isn''t a "' || $2 || '" it''s a "' || typeof || '"');
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="regtype"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="isdefined(hstore, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_defined]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="isexists(hstore, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_exists]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt(anyelement, anyelement)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isnt( $1, $2, NULL);]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt(anyelement, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    result BOOLEAN;
    output TEXT;
BEGIN
    result := $1 IS DISTINCT FROM $2;
    output := ok( result, $3 );
    RETURN output || CASE result WHEN TRUE THEN '' ELSE E'\n' || diag(
           '        have: ' || COALESCE( $1::text, 'NULL' ) ||
        E'\n        want: anything else'
    ) END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_aggregate(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, NOT _type_func('a', $1),
        'Function ' || quote_ident($1) || '() should not be an aggregate function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_aggregate(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, NOT _type_func('a', $1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should not be an aggregate function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_aggregate(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, $3, NOT _type_func('a', $1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should not be an aggregate function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_aggregate(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, NOT _type_func('a', $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_aggregate(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, NOT _type_func('a', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_aggregate(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, $2, NOT _type_func('a', $1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should not be an aggregate function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_aggregate(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, NOT _type_func('a', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_aggregate(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, NOT _type_func('a', $1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_ancestor_of(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT  _ancestor_of( $1, $2, NULL ),
        'Table ' || quote_ident( $1 ) || ' should not be an ancestor of ' || quote_ident( $2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_ancestor_of(name, name, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT  _ancestor_of( $1, $2, $3 ),
        'Table ' || quote_ident( $1 ) || ' should not be ancestor ' || $3 || ' of ' || quote_ident( $2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_ancestor_of(name, name, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT  _ancestor_of( $1, $2, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_ancestor_of(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT  _ancestor_of( $1, $2, $3, $4, NULL ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 )
        || ' should not be an ancestor of '
        || quote_ident( $3 ) || '.' || quote_ident( $4 )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_ancestor_of(name, name, name, name, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT  _ancestor_of( $1, $2, $3, $4, $5 ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 )
        || ' should not be ancestor ' || $5 || ' for '
        || quote_ident( $3 ) || '.' || quote_ident( $4 )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_ancestor_of(name, name, name, name, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT  _ancestor_of( $1, $2, $3, $4, $5 ), $6 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_ancestor_of(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT  _ancestor_of( $1, $2, $3, $4, NULL ), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_ancestor_of(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT  _ancestor_of( $1, $2, NULL ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_definer(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _definer($1), 'Function ' || quote_ident($1) || '() should not be security definer' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_definer(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _definer($1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should not be security definer'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_definer(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _definer($1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should not be security definer'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_definer(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, NOT _definer($1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_definer(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, NOT _definer($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_definer(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _definer($1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should not be security definer'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_definer(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, NOT _definer($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_definer(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, NOT _definer($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_descendent_of(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
       NOT  _ancestor_of( $2, $1, NULL ),
        'Table ' || quote_ident( $1 ) || ' should not be a descendent of ' || quote_ident( $2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_descendent_of(name, name, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
       NOT  _ancestor_of( $2, $1, $3 ),
        'Table ' || quote_ident( $1 ) || ' should not be descendent ' || $3 || ' from ' || quote_ident( $2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_descendent_of(name, name, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(NOT  _ancestor_of( $2, $1, $3 ), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_descendent_of(name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
       NOT  _ancestor_of( $3, $4, $1, $2, NULL ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 )
        || ' should not be a descendent of '
        || quote_ident( $3 ) || '.' || quote_ident( $4 )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_descendent_of(name, name, name, name, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
       NOT  _ancestor_of( $3, $4, $1, $2, $5 ),
        'Table ' || quote_ident( $1 ) || '.' || quote_ident( $2 )
        || ' should not be descendent ' || $5 || ' from '
        || quote_ident( $3 ) || '.' || quote_ident( $4 )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_descendent_of(name, name, name, name, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(NOT  _ancestor_of( $3, $4, $1, $2, $5 ), $6 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_descendent_of(name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(NOT  _ancestor_of( $3, $4, $1, $2, NULL ), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_descendent_of(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(NOT  _ancestor_of( $2, $1, NULL ), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_empty(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isnt_empty( $1, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_empty(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    res  BOOLEAN := FALSE;
    rec  RECORD;
BEGIN
    -- Find extra records.
    FOR rec in EXECUTE _query($1) LOOP
        res := TRUE;
        EXIT;
    END LOOP;

    RETURN ok(res, $2);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_member_of(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isnt_member_of( $1, ARRAY[$2] );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_member_of(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isnt_member_of( $1, ARRAY[$2], $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_member_of(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isnt_member_of( $1, $2, 'Should not have members of role ' || quote_ident($1) );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_member_of(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    extra text[];
BEGIN
    IF NOT _has_role($1) THEN
        RETURN fail( $3 ) || E'\n' || diag (
            '    Role ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    SELECT ARRAY(
        SELECT quote_ident($2[i])
          FROM generate_series(1, array_upper($2, 1)) s(i)
          LEFT JOIN pg_catalog.pg_roles r ON rolname = $2[i]
         WHERE r.oid = ANY ( _grolist($1) )
         ORDER BY s.i
    ) INTO extra;
    IF extra[1] IS NULL THEN
        RETURN ok( true, $3 );
    END IF;
    RETURN ok( false, $3 ) || E'\n' || diag(
        '    Members, who should not be in ' || quote_ident($1) || E' role:\n        ' ||
        array_to_string( extra, E'\n        ')
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_normal_function(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, NOT _type_func('f', $1),
        'Function ' || quote_ident($1) || '() should not be a normal function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_normal_function(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, NOT _type_func('f', $1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should not be a normal function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_normal_function(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, $3, NOT _type_func('f', $1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should not be a normal function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_normal_function(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, NOT _type_func('f', $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_normal_function(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, NOT _type_func('f', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_normal_function(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, $2,
        NOT _type_func('f', $1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should not be a normal function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_normal_function(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, NOT _type_func('f', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_normal_function(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, NOT _type_func('f', $1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_partitioned(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _rexists('p', $1),
        'Table ' || quote_ident($1) || ' should not be partitioned'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_partitioned(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _rexists('p', $1, $2),
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should not be partitioned'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_partitioned(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists('p', $1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_partitioned(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _rexists('p', $1), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_procedure(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, NOT _type_func('p', $1),
        'Function ' || quote_ident($1) || '() should not be a procedure'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_procedure(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2,  NOT _type_func('p', $1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should not be a procedure'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_procedure(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, $3, NOT _type_func('p', $1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should not be a procedure'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_procedure(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, NOT _type_func('p', $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_procedure(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, NOT _type_func('p', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_procedure(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, $2, NOT _type_func('p', $1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should not be a procedure'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_procedure(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, NOT _type_func('p', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_procedure(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, NOT _type_func('p', $1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_strict(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( NOT _strict($1), 'Function ' || quote_ident($1) || '() should not be strict' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_strict(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _strict($1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should not be strict'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_strict(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _strict($1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should not be strict'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_strict(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, NOT _strict($1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_strict(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, NOT _strict($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_strict(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok(
        NOT _strict($1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should not be strict'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_strict(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, NOT _strict($1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_strict(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, NOT _strict($1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_superuser(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT isnt_superuser( $1, 'User ' || quote_ident($1) || ' should not be a super user' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_superuser(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    is_super boolean := _is_super($1);
BEGIN
    IF is_super IS NULL THEN
        RETURN fail( $2 ) || E'\n' || diag( '    User ' || quote_ident($1) || ' does not exist') ;
    END IF;
    RETURN ok( NOT is_super, $2 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_window(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, NOT _type_func('w', $1),
        'Function ' || quote_ident($1) || '() should not be a window function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_window(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, NOT _type_func('w', $1, $2),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '() should not be a window function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_window(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        $1, $2, $3, NOT _type_func('w', $1, $2, $3),
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should not be a window function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_window(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, NOT _type_func('w', $1, $2, $3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_window(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, NOT _type_func('w', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_window(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(
        NULL, $1, $2, NOT _type_func('w', $1, $2),
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should not be a window function'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_window(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, NOT _type_func('w', $1, $2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="isnt_window(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, NOT _type_func('w', $1), $2 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="language_is_trusted(name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT language_is_trusted($1, 'Procedural language ' || quote_ident($1) || ' should be trusted' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="language_is_trusted(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    is_trusted boolean := _is_trusted($1);
BEGIN
    IF is_trusted IS NULL THEN
        RETURN fail( $2 ) || E'\n' || diag( '    Procedural language ' || quote_ident($1) || ' does not exist') ;
    END IF;
    RETURN ok( is_trusted, $2 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="language_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT language_owner_is(
        $1, $2,
        'Language ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="language_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_language_owner($1);
BEGIN
    -- Make sure the language exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Language ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="language_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT language_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on language ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="language_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_lang_privs( $2, quote_ident($1) );
BEGIN
    IF grants[1] = 'undefined_language' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Language ' || quote_ident($1) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="languages_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT languages_are( $1, 'There should be the correct procedural languages' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="languages_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'languages',
        ARRAY(
            SELECT lanname
              FROM pg_catalog.pg_language
             WHERE lanispl
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT lanname
              FROM pg_catalog.pg_language
             WHERE lanispl
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lives_ok(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT lives_ok( $1, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lives_ok(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    code  TEXT := _query($1);
    descr ALIAS FOR $2;
    detail  text;
    hint    text;
    context text;
    schname text;
    tabname text;
    colname text;
    chkname text;
    typname text;
BEGIN
    EXECUTE code;
    RETURN ok( TRUE, descr );
EXCEPTION WHEN OTHERS OR ASSERT_FAILURE THEN
    -- There should have been no exception.
    GET STACKED DIAGNOSTICS
        detail  = PG_EXCEPTION_DETAIL,
        hint    = PG_EXCEPTION_HINT,
        context = PG_EXCEPTION_CONTEXT,
        schname = SCHEMA_NAME,
        tabname = TABLE_NAME,
        colname = COLUMN_NAME,
        chkname = CONSTRAINT_NAME,
        typname = PG_DATATYPE_NAME;
    RETURN ok( FALSE, descr ) || E'\n' || diag(
           '    died: ' || _error_diag(SQLSTATE, SQLERRM, detail, hint, context, schname, tabname, colname, chkname, typname)
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="matches(anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _alike( $1 ~ $2, $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="matches(anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _alike( $1 ~ $2, $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="materialized_view_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT materialized_view_owner_is(
        $1, $2,
        'Materialized view ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="materialized_view_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT materialized_view_owner_is(
        $1, $2, $3,
        'Materialized view ' || quote_ident($1) || '.' || quote_ident($2) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="materialized_view_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('m'::char, $1, $2);
BEGIN
    -- Make sure the materialized view exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Materialized view ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="materialized_view_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('m'::char, $1);
BEGIN
    -- Make sure the materialized view exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Materialized view ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="materialized_views_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'Materialized views', _extras('m', $1, $2), _missing('m', $1, $2),
        'Schema ' || quote_ident($1) || ' should have the correct materialized views'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="materialized_views_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'Materialized views', _extras('m', $1, $2), _missing('m', $1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="materialized_views_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'Materialized views', _extras('m', $1), _missing('m', $1),
        'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct materialized views'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="materialized_views_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'Materialized views', _extras('m', $1), _missing('m', $1), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="no_plan()" returnType="SETOF boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    PERFORM plan(0);
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="num_failed()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _get('failed');]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="oid_dist(oid, oid)" returnType="oid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[oid_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="oid"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="ok(boolean)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( $1, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="ok(boolean, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
   aok      ALIAS FOR $1;
   descr    text := $2;
   test_num INTEGER;
   todo_why TEXT;
   ok       BOOL;
BEGIN
   todo_why := _todo();
   ok       := CASE
       WHEN aok = TRUE THEN aok
       WHEN todo_why IS NULL THEN COALESCE(aok, false)
       ELSE TRUE
    END;
    IF _get('plan') IS NULL THEN
        RAISE EXCEPTION 'You tried to run a test without a plan! Gotta have a plan';
    END IF;

    test_num := add_result(
        ok,
        COALESCE(aok, false),
        descr,
        CASE WHEN todo_why IS NULL THEN '' ELSE 'todo' END,
        COALESCE(todo_why, '')
    );

    RETURN (CASE aok WHEN TRUE THEN '' ELSE 'not ' END)
           || 'ok ' || _set( 'curr_test', test_num )
           || CASE descr WHEN '' THEN '' ELSE COALESCE( ' - ' || substr(diag( descr ), 3), '' ) END
           || COALESCE( ' ' || diag( 'TODO ' || todo_why ), '')
           || CASE aok WHEN TRUE THEN '' ELSE E'\n' ||
                diag('Failed ' ||
                CASE WHEN todo_why IS NULL THEN '' ELSE '(TODO) ' END ||
                'test ' || test_num ||
                CASE descr WHEN '' THEN '' ELSE COALESCE(': "' || descr || '"', '') END ) ||
                CASE WHEN aok IS NULL THEN E'\n' || diag('    (test result was NULL)') ELSE '' END
           END;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="opclass_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT opclass_owner_is(
        $1, $2,
        'Operator class ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="opclass_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT opclass_owner_is(
        $1, $2, $3,
        'Operator class ' || quote_ident($1) || '.' || quote_ident($2) ||
        ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="opclass_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_opclass_owner($1, $2);
BEGIN
    -- Make sure the opclass exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Operator class ' || quote_ident($1) || '.' || quote_ident($2)
            || ' not found'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="opclass_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_opclass_owner($1);
BEGIN
    -- Make sure the opclass exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Operator class ' || quote_ident($1) || ' not found'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="opclasses_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT opclasses_are( $1, $2, 'Schema ' || quote_ident($1) || ' should have the correct operator classes' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="opclasses_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'operator classes',
        ARRAY(
            SELECT oc.opcname
              FROM pg_catalog.pg_opclass oc
              JOIN pg_catalog.pg_namespace n ON oc.opcnamespace = n.oid
             WHERE n.nspname  = $1
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
               FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT oc.opcname
              FROM pg_catalog.pg_opclass oc
              JOIN pg_catalog.pg_namespace n ON oc.opcnamespace = n.oid
             WHERE n.nspname  = $1
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="opclasses_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT opclasses_are( $1, 'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct operator classes' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="opclasses_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'operator classes',
        ARRAY(
            SELECT oc.opcname
              FROM pg_catalog.pg_opclass oc
              JOIN pg_catalog.pg_namespace n ON oc.opcnamespace = n.oid
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND pg_catalog.pg_opclass_is_visible(oc.oid)
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
               FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT oc.opcname
              FROM pg_catalog.pg_opclass oc
              JOIN pg_catalog.pg_namespace n ON oc.opcnamespace = n.oid
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND pg_catalog.pg_opclass_is_visible(oc.oid)
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="operators_are(name, text[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT operators_are($1, $2, 'Schema ' || quote_ident($1) || ' should have the correct operators' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="operators_are(name, text[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _areni(
        'operators',
        ARRAY(
            SELECT display_oper(o.oprname, o.oid) || ' RETURNS ' || o.oprresult::regtype
              FROM pg_catalog.pg_operator o
              JOIN pg_catalog.pg_namespace n ON o.oprnamespace = n.oid
             WHERE n.nspname = $1
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT display_oper(o.oprname, o.oid) || ' RETURNS ' || o.oprresult::regtype
              FROM pg_catalog.pg_operator o
              JOIN pg_catalog.pg_namespace n ON o.oprnamespace = n.oid
             WHERE n.nspname = $1
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="operators_are(text[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT operators_are($1, 'There should be the correct operators')]]></definition>
         <parameters>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="operators_are(text[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _areni(
        'operators',
        ARRAY(
            SELECT display_oper(o.oprname, o.oid) || ' RETURNS ' || o.oprresult::regtype
              FROM pg_catalog.pg_operator o
              JOIN pg_catalog.pg_namespace n ON o.oprnamespace = n.oid
             WHERE pg_catalog.pg_operator_is_visible(o.oid)
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT display_oper(o.oprname, o.oid) || ' RETURNS ' || o.oprresult::regtype
              FROM pg_catalog.pg_operator o
              JOIN pg_catalog.pg_namespace n ON o.oprnamespace = n.oid
             WHERE pg_catalog.pg_operator_is_visible(o.oid)
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="os_name()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT 'linux'::text;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="partitions_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT partitions_are(
        $1, $2, $3,
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should have the correct partitions'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="partitions_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'partitions',
        ARRAY(SELECT _parts($1, $2) EXCEPT SELECT unnest($3)),
        ARRAY(SELECT unnest($3) EXCEPT SELECT _parts($1, $2)),
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="partitions_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT partitions_are(
        $1, $2,
        'Table ' || quote_ident($1) || ' should have the correct partitions'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="partitions_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'partitions',
        ARRAY(SELECT _parts($1) EXCEPT SELECT unnest($2)),
        ARRAY(SELECT unnest($2) EXCEPT SELECT _parts($1)),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pass()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( TRUE, NULL );]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pass(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( TRUE, $1 );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="performs_ok(text, numeric)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT performs_ok(
        $1, $2, 'Should run in less than ' || $2 || ' ms'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="numeric"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="performs_ok(text, numeric, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    query     TEXT := _query($1);
    max_time  ALIAS FOR $2;
    descr     ALIAS FOR $3;
    starts_at TEXT;
    act_time  NUMERIC;
BEGIN
    starts_at := timeofday();
    EXECUTE query;
    act_time := extract( millisecond from timeofday()::timestamptz - starts_at::timestamptz);
    IF act_time < max_time THEN RETURN ok(TRUE, descr); END IF;
    RETURN ok( FALSE, descr ) || E'\n' || diag(
           '      runtime: ' || act_time || ' ms' ||
        E'\n      exceeds: ' || max_time || ' ms'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="performs_within(text, numeric, numeric)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT performs_within(
          $1, $2, $3, 10,
          'Should run within ' || $2 || ' +/- ' || $3 || ' ms');]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="numeric"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="performs_within(text, numeric, numeric, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT performs_within(
          $1, $2, $3, $4,
          'Should run within ' || $2 || ' +/- ' || $3 || ' ms');]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="performs_within(text, numeric, numeric, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    query          TEXT := _query($1);
    expected_avg   ALIAS FOR $2;
    within         ALIAS FOR $3;
    iterations     ALIAS FOR $4;
    descr          ALIAS FOR $5;
    avg_time       NUMERIC;
BEGIN
  SELECT avg(a_time) FROM _time_trials(query, iterations, 0.8) t1 INTO avg_time;
  IF abs(avg_time - expected_avg) < within THEN RETURN ok(TRUE, descr); END IF;
  RETURN ok(FALSE, descr) || E'\n' || diag(' average runtime: ' || avg_time || ' ms'
     || E'\n desired average: ' || expected_avg || ' +/- ' || within || ' ms'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="performs_within(text, numeric, numeric, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT performs_within(
          $1, $2, $3, 10, $4
        );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="numeric"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pg_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT current_setting('server_version')]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pg_version_num()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT current_setting('server_version_num')::integer;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_armor_headers(text, OUT key text, OUT value text)" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_armor_headers]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="OUT" name="key" type="text"/>
            <parameter mode="OUT" name="value" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_key_id(bytea)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_key_id_w]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_pub_decrypt(bytea, bytea)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_decrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_pub_decrypt(bytea, bytea, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_decrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_pub_decrypt(bytea, bytea, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_decrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_pub_decrypt_bytea(bytea, bytea)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_decrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_pub_decrypt_bytea(bytea, bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_decrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_pub_decrypt_bytea(bytea, bytea, text, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_decrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_pub_encrypt(text, bytea)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_encrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_pub_encrypt(text, bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_encrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_pub_encrypt_bytea(bytea, bytea)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_encrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_pub_encrypt_bytea(bytea, bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_pub_encrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_sym_decrypt(bytea, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_sym_decrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_sym_decrypt(bytea, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_sym_decrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_sym_decrypt_bytea(bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_sym_decrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_sym_decrypt_bytea(bytea, text, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_sym_decrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_sym_encrypt(text, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_sym_encrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_sym_encrypt(text, text, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_sym_encrypt_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_sym_encrypt_bytea(bytea, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_sym_encrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_sym_encrypt_bytea(bytea, text, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgp_sym_encrypt_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgtap_version()" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT 1.2;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="plan(integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    rcount INTEGER;
BEGIN
    BEGIN
        EXECUTE '
            CREATE TEMP SEQUENCE __tcache___id_seq;
            CREATE TEMP TABLE __tcache__ (
                id    INTEGER NOT NULL DEFAULT nextval(''__tcache___id_seq''),
                label TEXT    NOT NULL,
                value INTEGER NOT NULL,
                note  TEXT    NOT NULL DEFAULT ''''
            );
            CREATE UNIQUE INDEX __tcache___key ON __tcache__(id);
            GRANT ALL ON TABLE __tcache__ TO PUBLIC;
            GRANT ALL ON TABLE __tcache___id_seq TO PUBLIC;

            CREATE TEMP SEQUENCE __tresults___numb_seq;
            GRANT ALL ON TABLE __tresults___numb_seq TO PUBLIC;
        ';

    EXCEPTION WHEN duplicate_table THEN
        -- Raise an exception if there's already a plan.
        EXECUTE 'SELECT TRUE FROM __tcache__ WHERE label = ''plan''';
      GET DIAGNOSTICS rcount = ROW_COUNT;
        IF rcount > 0 THEN
           RAISE EXCEPTION 'You tried to plan twice!';
        END IF;
    END;

    -- Save the plan and return.
    PERFORM _set('plan', $1 );
    PERFORM _set('failed', 0 );
    RETURN '1..' || $1;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policies_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT policies_are( $1, $2, $3, 'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should have the correct policies' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policies_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'policies',
        ARRAY(
            SELECT p.polname
              FROM pg_catalog.pg_policy p
              JOIN pg_catalog.pg_class c     ON c.oid = p.polrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
             WHERE n.nspname = $1
               AND c.relname = $2
            EXCEPT
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
        ),
        ARRAY(
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
            EXCEPT
            SELECT p.polname
              FROM pg_catalog.pg_policy p
              JOIN pg_catalog.pg_class c     ON c.oid = p.polrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
             WHERE n.nspname = $1
               AND c.relname = $2
        ),
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policies_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT policies_are( $1, $2, 'Table ' || quote_ident($1) || ' should have the correct policies' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policies_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'policies',
        ARRAY(
            SELECT p.polname
              FROM pg_catalog.pg_policy p
              JOIN pg_catalog.pg_class c ON c.oid = p.polrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
             WHERE c.relname = $1
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT p.polname
              FROM pg_catalog.pg_policy p
              JOIN pg_catalog.pg_class c ON c.oid = p.polrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policy_cmd_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT policy_cmd_is(
        $1, $2, $3, $4,
        'Policy ' || quote_ident($3)
        || ' for table ' || quote_ident($1) || '.' || quote_ident($2)
        || ' should apply to ' || upper($4) || ' command'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policy_cmd_is(name, name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    cmd text;
BEGIN
    SELECT
      CASE pp.polcmd WHEN 'r' THEN 'SELECT'
                     WHEN 'a' THEN 'INSERT'
                     WHEN 'w' THEN 'UPDATE'
                     WHEN 'd' THEN 'DELETE'
                     ELSE 'ALL'
       END
      FROM pg_catalog.pg_policy AS pp
      JOIN pg_catalog.pg_class AS pc ON pc.oid = pp.polrelid
      JOIN pg_catalog.pg_namespace AS pn ON pn.oid = pc.relnamespace
     WHERE pn.nspname = $1
       AND pc.relname = $2
       AND pp.polname = $3
      INTO cmd;

    RETURN is( cmd, upper($4), $5 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policy_cmd_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT policy_cmd_is(
        $1, $2, $3,
        'Policy ' || quote_ident($2)
        || ' for table ' || quote_ident($1)
        || ' should apply to ' || upper($3) || ' command'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policy_cmd_is(name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    cmd text;
BEGIN
    SELECT
      CASE pp.polcmd WHEN 'r' THEN 'SELECT'
                     WHEN 'a' THEN 'INSERT'
                     WHEN 'w' THEN 'UPDATE'
                     WHEN 'd' THEN 'DELETE'
                     ELSE 'ALL'
       END
      FROM pg_catalog.pg_policy AS pp
      JOIN pg_catalog.pg_class AS pc ON pc.oid = pp.polrelid
      JOIN pg_catalog.pg_namespace AS pn ON pn.oid = pc.relnamespace
     WHERE pc.relname = $1
       AND pp.polname = $2
       AND pn.nspname NOT IN ('pg_catalog', 'information_schema')
      INTO cmd;

    RETURN is( cmd, upper($3), $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policy_roles_are(name, name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT policy_roles_are( $1, $2, $3, $4, 'Policy ' || quote_ident($3) || ' for table ' || quote_ident($1) || '.' || quote_ident($2) || ' should have the correct roles' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policy_roles_are(name, name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'policy roles',
        ARRAY(
            SELECT pr.rolname
              FROM pg_catalog.pg_policy AS pp
              JOIN pg_catalog.pg_roles AS pr ON pr.oid = ANY (pp.polroles)
              JOIN pg_catalog.pg_class AS pc ON pc.oid = pp.polrelid
              JOIN pg_catalog.pg_namespace AS pn ON pn.oid = pc.relnamespace
             WHERE pn.nspname = $1
               AND pc.relname = $2
               AND pp.polname = $3
            EXCEPT
            SELECT $4[i]
              FROM generate_series(1, array_upper($4, 1)) s(i)
        ),
        ARRAY(
            SELECT $4[i]
              FROM generate_series(1, array_upper($4, 1)) s(i)
            EXCEPT
            SELECT pr.rolname
              FROM pg_catalog.pg_policy AS pp
              JOIN pg_catalog.pg_roles AS pr ON pr.oid = ANY (pp.polroles)
              JOIN pg_catalog.pg_class AS pc ON pc.oid = pp.polrelid
              JOIN pg_catalog.pg_namespace AS pn ON pn.oid = pc.relnamespace
             WHERE pn.nspname = $1
               AND pc.relname = $2
               AND pp.polname = $3
        ),
        $5
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policy_roles_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT policy_roles_are( $1, $2, $3, 'Policy ' || quote_ident($2) || ' for table ' || quote_ident($1) || ' should have the correct roles' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="policy_roles_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'policy roles',
        ARRAY(
            SELECT pr.rolname
              FROM pg_catalog.pg_policy AS pp
              JOIN pg_catalog.pg_roles AS pr ON pr.oid = ANY (pp.polroles)
              JOIN pg_catalog.pg_class AS pc ON pc.oid = pp.polrelid
              JOIN pg_catalog.pg_namespace AS pn ON pn.oid = pc.relnamespace
             WHERE pc.relname = $1
               AND pp.polname = $2
               AND pn.nspname NOT IN ('pg_catalog', 'information_schema')
            EXCEPT
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
        ),
        ARRAY(
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
            EXCEPT
            SELECT pr.rolname
              FROM pg_catalog.pg_policy AS pp
              JOIN pg_catalog.pg_roles AS pr ON pr.oid = ANY (pp.polroles)
              JOIN pg_catalog.pg_class AS pc ON pc.oid = pp.polrelid
              JOIN pg_catalog.pg_namespace AS pn ON pn.oid = pc.relnamespace
             WHERE pc.relname = $1
               AND pp.polname = $2
               AND pn.nspname NOT IN ('pg_catalog', 'information_schema')
        ),
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="populate_record(anyelement, hstore)" returnType="anyelement" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_populate_record]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="relation_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT relation_owner_is(
        $1, $2,
        'Relation ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="relation_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT relation_owner_is(
        $1, $2, $3,
        'Relation ' || quote_ident($1) || '.' || quote_ident($2) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="relation_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner($1, $2);
BEGIN
    -- Make sure the relation exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Relation ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="relation_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner($1);
BEGIN
    -- Make sure the relation exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Relation ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(refcursor, anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_eq( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(refcursor, anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    want REFCURSOR;
    res  TEXT;
BEGIN
    OPEN want FOR SELECT $2[i]
    FROM generate_series(array_lower($2, 1), array_upper($2, 1)) s(i);
    res := results_eq($1, want, $3);
    CLOSE want;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(refcursor, refcursor)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_eq( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="refcursor"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(refcursor, refcursor, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have       ALIAS FOR $1;
    want       ALIAS FOR $2;
    have_rec   RECORD;
    want_rec   RECORD;
    have_found BOOLEAN;
    want_found BOOLEAN;
    rownum     INTEGER := 1;
    err_msg    text := 'details not available in pg <= 9.1';
BEGIN
    FETCH have INTO have_rec;
    have_found := FOUND;
    FETCH want INTO want_rec;
    want_found := FOUND;
    WHILE have_found OR want_found LOOP
        IF have_rec IS DISTINCT FROM want_rec OR have_found <> want_found THEN
            RETURN ok( false, $3 ) || E'\n' || diag(
                '    Results differ beginning at row ' || rownum || E':\n' ||
                '        have: ' || CASE WHEN have_found THEN have_rec::text ELSE 'NULL' END || E'\n' ||
                '        want: ' || CASE WHEN want_found THEN want_rec::text ELSE 'NULL' END
            );
        END IF;
        rownum = rownum + 1;
        FETCH have INTO have_rec;
        have_found := FOUND;
        FETCH want INTO want_rec;
        want_found := FOUND;
    END LOOP;

    RETURN ok( true, $3 );
EXCEPTION
    WHEN datatype_mismatch THEN
        GET STACKED DIAGNOSTICS err_msg = MESSAGE_TEXT;
        RETURN ok( false, $3 ) || E'\n' || diag(
            E'    Number of columns or their types differ between the queries' ||
            CASE WHEN have_rec::TEXT = want_rec::text THEN '' ELSE E':\n' ||
                '        have: ' || CASE WHEN have_found THEN have_rec::text ELSE 'NULL' END || E'\n' ||
                '        want: ' || CASE WHEN want_found THEN want_rec::text ELSE 'NULL' END
            END || E'\n        ERROR: ' || err_msg
        );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(refcursor, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_eq( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(refcursor, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    want REFCURSOR;
    res  TEXT;
BEGIN
    OPEN want FOR EXECUTE _query($2);
    res := results_eq($1, want, $3);
    CLOSE want;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(text, anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_eq( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(text, anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have REFCURSOR;
    want REFCURSOR;
    res  TEXT;
BEGIN
    OPEN have FOR EXECUTE _query($1);
    OPEN want FOR SELECT $2[i]
    FROM generate_series(array_lower($2, 1), array_upper($2, 1)) s(i);
    res := results_eq(have, want, $3);
    CLOSE have;
    CLOSE want;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(text, refcursor)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_eq( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="refcursor"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(text, refcursor, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have REFCURSOR;
    res  TEXT;
BEGIN
    OPEN have FOR EXECUTE _query($1);
    res := results_eq(have, $2, $3);
    CLOSE have;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_eq( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_eq(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have REFCURSOR;
    want REFCURSOR;
    res  TEXT;
BEGIN
    OPEN have FOR EXECUTE _query($1);
    OPEN want FOR EXECUTE _query($2);
    res := results_eq(have, want, $3);
    CLOSE have;
    CLOSE want;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(refcursor, anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_ne( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(refcursor, anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    want REFCURSOR;
    res  TEXT;
BEGIN
    OPEN want FOR SELECT $2[i]
    FROM generate_series(array_lower($2, 1), array_upper($2, 1)) s(i);
    res := results_ne($1, want, $3);
    CLOSE want;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(refcursor, refcursor)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_ne( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="refcursor"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(refcursor, refcursor, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have       ALIAS FOR $1;
    want       ALIAS FOR $2;
    have_rec   RECORD;
    want_rec   RECORD;
    have_found BOOLEAN;
    want_found BOOLEAN;
    err_msg    text := 'details not available in pg <= 9.1';
BEGIN
    FETCH have INTO have_rec;
    have_found := FOUND;
    FETCH want INTO want_rec;
    want_found := FOUND;
    WHILE have_found OR want_found LOOP
        IF have_rec IS DISTINCT FROM want_rec OR have_found <> want_found THEN
            RETURN ok( true, $3 );
        ELSE
            FETCH have INTO have_rec;
            have_found := FOUND;
            FETCH want INTO want_rec;
            want_found := FOUND;
        END IF;
    END LOOP;
    RETURN ok( false, $3 );
EXCEPTION
    WHEN datatype_mismatch THEN
        GET STACKED DIAGNOSTICS err_msg = MESSAGE_TEXT;
        RETURN ok( false, $3 ) || E'\n' || diag(
            E'    Number of columns or their types differ between the queries' ||
            CASE WHEN have_rec::TEXT = want_rec::text THEN '' ELSE E':\n' ||
                '        have: ' || CASE WHEN have_found THEN have_rec::text ELSE 'NULL' END || E'\n' ||
                '        want: ' || CASE WHEN want_found THEN want_rec::text ELSE 'NULL' END
            END || E'\n        ERROR: ' || err_msg
        );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(refcursor, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_ne( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(refcursor, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    want REFCURSOR;
    res  TEXT;
BEGIN
    OPEN want FOR EXECUTE _query($2);
    res := results_ne($1, want, $3);
    CLOSE want;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(text, anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_ne( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(text, anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have REFCURSOR;
    want REFCURSOR;
    res  TEXT;
BEGIN
    OPEN have FOR EXECUTE _query($1);
    OPEN want FOR SELECT $2[i]
    FROM generate_series(array_lower($2, 1), array_upper($2, 1)) s(i);
    res := results_ne(have, want, $3);
    CLOSE have;
    CLOSE want;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(text, refcursor)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_ne( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="refcursor"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(text, refcursor, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have REFCURSOR;
    res  TEXT;
BEGIN
    OPEN have FOR EXECUTE _query($1);
    res := results_ne(have, $2, $3);
    CLOSE have;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="refcursor"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT results_ne( $1, $2, NULL::text );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="results_ne(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    have REFCURSOR;
    want REFCURSOR;
    res  TEXT;
BEGIN
    OPEN have FOR EXECUTE _query($1);
    OPEN want FOR EXECUTE _query($2);
    res := results_ne(have, want, $3);
    CLOSE have;
    CLOSE want;
    RETURN res;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="roles_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT roles_are( $1, 'There should be the correct roles' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="roles_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'roles',
        ARRAY(
            SELECT rolname
              FROM pg_catalog.pg_roles
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT rolname
              FROM pg_catalog.pg_roles
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="row_eq(text, anyelement)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT row_eq($1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="row_eq(text, anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    rec    RECORD;
BEGIN
    EXECUTE _query($1) INTO rec;
    IF NOT rec IS DISTINCT FROM $2 THEN RETURN ok(true, $3); END IF;
    RETURN ok(false, $3 ) || E'\n' || diag(
           '        have: ' || CASE WHEN rec IS NULL THEN 'NULL' ELSE rec::text END ||
        E'\n        want: ' || CASE WHEN $2  IS NULL THEN 'NULL' ELSE $2::text  END
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rule_is_instead(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT rule_is_instead($1, $2, 'Rule ' || quote_ident($2) || ' on relation ' || quote_ident($1) || ' should be an INSTEAD rule' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rule_is_instead(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT rule_is_instead( $1, $2, $3, 'Rule ' || quote_ident($3) || ' on relation ' || quote_ident($1) || '.' || quote_ident($2) || ' should be an INSTEAD rule' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rule_is_instead(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    is_it boolean := _is_instead($1, $2, $3);
BEGIN
    IF is_it IS NOT NULL THEN RETURN ok( is_it, $4 ); END IF;
    RETURN ok( FALSE, $4 ) || E'\n' || diag(
        '    Rule ' || quote_ident($3) || ' does not exist'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rule_is_instead(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    is_it boolean := _is_instead($1, $2);
BEGIN
    IF is_it IS NOT NULL THEN RETURN ok( is_it, $3 ); END IF;
    RETURN ok( FALSE, $3 ) || E'\n' || diag(
        '    Rule ' || quote_ident($2) || ' does not exist'
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rule_is_on(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT rule_is_on(
        $1, $2, $3, $4,
        'Rule ' || quote_ident($3) || ' should be on ' || _expand_on(_contract_on($4)::char)
        || ' to ' || quote_ident($1) || '.' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rule_is_on(name, name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    want char := _contract_on($4);
    have char := _rule_on($1, $2, $3);
BEGIN
    IF have IS NOT NULL THEN
        RETURN is( _expand_on(have), _expand_on(want), $5 );
    END IF;

    RETURN ok( false, $5 ) || E'\n' || diag(
        '    Rule ' || quote_ident($3) || ' does not exist on '
        || quote_ident($1) || '.' || quote_ident($2)
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rule_is_on(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT rule_is_on(
        $1, $2, $3,
        'Rule ' || quote_ident($2) || ' should be on '
        || _expand_on(_contract_on($3)::char) || ' to ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rule_is_on(name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    want char := _contract_on($3);
    have char := _rule_on($1, $2);
BEGIN
    IF have IS NOT NULL THEN
        RETURN is( _expand_on(have), _expand_on(want), $4 );
    END IF;

    RETURN ok( false, $4 ) || E'\n' || diag(
        '    Rule ' || quote_ident($2) || ' does not exist on '
        || quote_ident($1)
    );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rules_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT rules_are( $1, $2, $3, 'Relation ' || quote_ident($1) || '.' || quote_ident($2) || ' should have the correct rules' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rules_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'rules',
        ARRAY(
            SELECT r.rulename
              FROM pg_catalog.pg_rewrite r
              JOIN pg_catalog.pg_class c     ON c.oid = r.ev_class
              JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
             WHERE c.relname = $2
               AND n.nspname = $1
            EXCEPT
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
        ),
        ARRAY(
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
            EXCEPT
            SELECT r.rulename
              FROM pg_catalog.pg_rewrite r
              JOIN pg_catalog.pg_class c     ON c.oid = r.ev_class
              JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
             WHERE c.relname = $2
               AND n.nspname = $1
        ),
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rules_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT rules_are( $1, $2, 'Relation ' || quote_ident($1) || ' should have the correct rules' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rules_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'rules',
        ARRAY(
            SELECT r.rulename
              FROM pg_catalog.pg_rewrite r
              JOIN pg_catalog.pg_class c     ON c.oid = r.ev_class
              JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
             WHERE c.relname = $1
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND pg_catalog.pg_table_is_visible(c.oid)
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT r.rulename
              FROM pg_catalog.pg_rewrite r
              JOIN pg_catalog.pg_class c     ON c.oid = r.ev_class
              JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
               AND c.relname = $1
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND pg_catalog.pg_table_is_visible(c.oid)
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="runtests()" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM runtests( '^test' );]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="runtests(name)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM runtests( $1, '^test' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="runtests(name, text)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _runner(
        findfuncs( $1, '^startup' ),
        findfuncs( $1, '^shutdown' ),
        findfuncs( $1, '^setup' ),
        findfuncs( $1, '^teardown' ),
        findfuncs( $1, $2, '^(startup|shutdown|setup|teardown)' )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="runtests(text)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT * FROM _runner(
        findfuncs( '^startup' ),
        findfuncs( '^shutdown' ),
        findfuncs( '^setup' ),
        findfuncs( '^teardown' ),
        findfuncs( $1, '^(startup|shutdown|setup|teardown)' )
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="schema_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT schema_owner_is(
        $1, $2,
        'Schema ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="schema_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_schema_owner($1);
BEGIN
    -- Make sure the schema exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Schema ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="schema_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT schema_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on schema ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="schema_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_schema_privs( $2, $1::TEXT );
BEGIN
    IF grants[1] = 'invalid_schema_name' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Schema ' || quote_ident($1) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="schemas_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT schemas_are( $1, 'There should be the correct schemas' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="schemas_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'schemas',
        ARRAY(
            SELECT nspname
              FROM pg_catalog.pg_namespace
             WHERE nspname NOT LIKE 'pg_%'
               AND nspname <> 'information_schema'
             EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT nspname
              FROM pg_catalog.pg_namespace
             WHERE nspname NOT LIKE 'pg_%'
               AND nspname <> 'information_schema'
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequence_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT sequence_owner_is(
        $1, $2,
        'Sequence ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequence_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT sequence_owner_is(
        $1, $2, $3,
        'Sequence ' || quote_ident($1) || '.' || quote_ident($2) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequence_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('S'::char, $1, $2);
BEGIN
    -- Make sure the sequence exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Sequence ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequence_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('S'::char, $1);
BEGIN
    -- Make sure the sequence exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Sequence ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequence_privs_are(name, name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT sequence_privs_are(
        $1, $2, $3, $4,
        'Role ' || quote_ident($3) || ' should be granted '
            || CASE WHEN $4[1] IS NULL THEN 'no privileges' ELSE array_to_string($4, ', ') END
            || ' on sequence '|| quote_ident($1) || '.' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequence_privs_are(name, name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_sequence_privs( $3, quote_ident($1) || '.' || quote_ident($2) );
BEGIN
    IF grants[1] = 'undefined_table' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Sequence ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Role ' || quote_ident($3) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $4, $5);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequence_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT sequence_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on sequence ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequence_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_sequence_privs( $2, quote_ident($1) );
BEGIN
    IF grants[1] = 'undefined_table' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Sequence ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequences_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'sequences', _extras('S', $1, $2), _missing('S', $1, $2),
        'Schema ' || quote_ident($1) || ' should have the correct sequences'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequences_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'sequences', _extras('S', $1, $2), _missing('S', $1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequences_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'sequences', _extras('S', $1), _missing('S', $1),
        'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct sequences'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="sequences_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'sequences', _extras('S', $1), _missing('S', $1), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="server_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT server_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on server ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="server_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_server_privs( $2, $1::TEXT );
BEGIN
    IF grants[1] = 'undefined_server' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Server ' || quote_ident($1) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_eq(text, anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, NULL::text, '' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_eq(text, anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, $3, '' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_eq(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, NULL::text, '' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_eq(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, $3, '' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_has(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, NULL::TEXT, 'EXCEPT', 'Missing' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_has(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, $3, 'EXCEPT', 'Missing' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_hasnt(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, NULL::TEXT, 'INTERSECT', 'Extra' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_hasnt(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relcomp( $1, $2, $3, 'INTERSECT', 'Extra' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_ne(text, anyarray)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relne( $1, $2, NULL::text, '' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_ne(text, anyarray, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relne( $1, $2, $3, '' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="anyarray"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_ne(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relne( $1, $2, NULL::text, '' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_ne(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _relne( $1, $2, $3, '' );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="skeys(hstore)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_skeys]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="skip(integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT skip(NULL, $1)]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="skip(integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT skip($2, $1)]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="skip(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ok( TRUE ) || ' ' || diag( 'SKIP' || COALESCE(' ' || $1, '') );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="skip(why text, how_many integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    output TEXT[];
BEGIN
    output := '{}';
    FOR i IN 1..how_many LOOP
        output = array_append(
            output,
            ok( TRUE ) || ' ' || diag( 'SKIP' || COALESCE( ' ' || why, '') )
        );
    END LOOP;
    RETURN array_to_string(output, E'\n');
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="why" type="text"/>
            <parameter mode="IN" name="how_many" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="slice(hstore, text[])" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_slice_to_hstore]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="slice_array(hstore, text[])" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_slice_to_array]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
            <parameter mode="IN" type="text[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="svals(hstore)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_svals]]></definition>
         <parameters>
            <parameter mode="IN" type="hstore"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="table_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT table_owner_is(
        $1, $2,
        'Table ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="table_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT table_owner_is(
        $1, $2, $3,
        'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="table_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('{r,p}'::char[], $1, $2);
BEGIN
    -- Make sure the table exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Table ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="table_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('{r,p}'::char[], $1);
BEGIN
    -- Make sure the table exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Table ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="table_privs_are(name, name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT table_privs_are(
        $1, $2, $3, $4,
        'Role ' || quote_ident($3) || ' should be granted '
            || CASE WHEN $4[1] IS NULL THEN 'no privileges' ELSE array_to_string($4, ', ') END
            || ' on table ' || quote_ident($1) || '.' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="table_privs_are(name, name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_table_privs( $3, quote_ident($1) || '.' || quote_ident($2) );
BEGIN
    IF grants[1] = 'undefined_table' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Table ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $5) || E'\n' || diag(
            '    Role ' || quote_ident($3) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $4, $5);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="table_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT table_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on table ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="table_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_table_privs( $2, quote_ident($1) );
BEGIN
    IF grants[1] = 'undefined_table' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Table ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tables_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'tables', _extras('{r,p}'::char[], $1, $2), _missing('{r,p}'::char[], $1, $2),
        'Schema ' || quote_ident($1) || ' should have the correct tables'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tables_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'tables', _extras('{r,p}'::char[], $1, $2), _missing('{r,p}'::char[], $1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tables_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'tables', _extras('{r,p}'::char[], $1), _missing('{r,p}'::char[], $1),
        'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct tables'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tables_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'tables', _extras('{r,p}'::char[], $1), _missing('{r,p}'::char[], $1), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tablespace_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT tablespace_owner_is(
        $1, $2,
        'Tablespace ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tablespace_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_tablespace_owner($1);
BEGIN
    -- Make sure the tablespace exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Tablespace ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tablespace_privs_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT tablespace_privs_are(
        $1, $2, $3,
        'Role ' || quote_ident($2) || ' should be granted '
            || CASE WHEN $3[1] IS NULL THEN 'no privileges' ELSE array_to_string($3, ', ') END
            || ' on tablespace ' || quote_ident($1)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tablespace_privs_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    grants TEXT[] := _get_tablespaceprivs( $2, $1::TEXT );
BEGIN
    IF grants[1] = 'undefined_tablespace' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Tablespace ' || quote_ident($1) || ' does not exist'
        );
    ELSIF grants[1] = 'undefined_role' THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            '    Role ' || quote_ident($2) || ' does not exist'
        );
    END IF;
    RETURN _assets_are('privileges', grants, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tablespaces_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT tablespaces_are( $1, 'There should be the correct tablespaces' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tablespaces_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'tablespaces',
        ARRAY(
            SELECT spcname
              FROM pg_catalog.pg_tablespace
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
               FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT spcname
              FROM pg_catalog.pg_tablespace
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="tconvert(text, text)" returnType="hstore" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[hstore_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ilike(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT throws_ilike($1, $2, 'Should throw exception like ' || quote_literal($2) );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ilike(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    EXECUTE _query($1);
    RETURN ok( FALSE, $3 ) || E'\n' || diag( '    no exception thrown' );
EXCEPTION WHEN OTHERS THEN
    return _tlike( SQLERRM ~~* $2, SQLERRM, $2, $3 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_imatching(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT throws_imatching($1, $2, 'Should throw exception matching ' || quote_literal($2) );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_imatching(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    EXECUTE _query($1);
    RETURN ok( FALSE, $3 ) || E'\n' || diag( '    no exception thrown' );
EXCEPTION WHEN OTHERS THEN
    return _tlike( SQLERRM ~* $2, SQLERRM, $2, $3 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_like(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT throws_like($1, $2, 'Should throw exception like ' || quote_literal($2) );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_like(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    EXECUTE _query($1);
    RETURN ok( FALSE, $3 ) || E'\n' || diag( '    no exception thrown' );
EXCEPTION WHEN OTHERS THEN
    return _tlike( SQLERRM ~~ $2, SQLERRM, $2, $3 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_matching(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT throws_matching($1, $2, 'Should throw exception matching ' || quote_literal($2) );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_matching(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    EXECUTE _query($1);
    RETURN ok( FALSE, $3 ) || E'\n' || diag( '    no exception thrown' );
EXCEPTION WHEN OTHERS THEN
    return _tlike( SQLERRM ~ $2, SQLERRM, $2, $3 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ok(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT throws_ok( $1, NULL, NULL, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ok(text, character, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    query     TEXT := _query($1);
    errcode   ALIAS FOR $2;
    errmsg    ALIAS FOR $3;
    desctext  ALIAS FOR $4;
    descr     TEXT;
BEGIN
    descr := COALESCE(
          desctext,
          'threw ' || errcode || ': ' || errmsg,
          'threw ' || errcode,
          'threw ' || errmsg,
          'threw an exception'
    );
    EXECUTE query;
    RETURN ok( FALSE, descr ) || E'\n' || diag(
           '      caught: no exception' ||
        E'\n      wanted: ' || COALESCE( errcode, 'an exception' )
    );
EXCEPTION WHEN OTHERS OR ASSERT_FAILURE THEN
    IF (errcode IS NULL OR SQLSTATE = errcode)
        AND ( errmsg IS NULL OR SQLERRM = errmsg)
    THEN
        -- The expected errcode and/or message was thrown.
        RETURN ok( TRUE, descr );
    ELSE
        -- This was not the expected errcode or errmsg.
        RETURN ok( FALSE, descr ) || E'\n' || diag(
               '      caught: ' || SQLSTATE || ': ' || SQLERRM ||
            E'\n      wanted: ' || COALESCE( errcode, 'an exception' ) ||
            COALESCE( ': ' || errmsg, '')
        );
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="character"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ok(text, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT throws_ok( $1, $2::char(5), NULL, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ok(text, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT throws_ok( $1, $2::char(5), $3, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ok(text, integer, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT throws_ok( $1, $2::char(5), $3, $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ok(text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF octet_length($2) = 5 THEN
        RETURN throws_ok( $1, $2::char(5), NULL, NULL );
    ELSE
        RETURN throws_ok( $1, NULL, $2, NULL );
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="throws_ok(text, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    IF octet_length($2) = 5 THEN
        RETURN throws_ok( $1, $2::char(5), $3, NULL );
    ELSE
        RETURN throws_ok( $1, NULL, $2, $3 );
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="time_dist(time without time zone, time without time zone)" returnType="interval" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[time_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="time without time zone"/>
            <parameter mode="IN" type="time without time zone"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="todo(how_many integer)" returnType="SETOF boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    PERFORM _add('todo', COALESCE(how_many, 1), '');
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="how_many" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="todo(how_many integer, why text)" returnType="SETOF boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    PERFORM _add('todo', COALESCE(how_many, 1), COALESCE(why, ''));
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="how_many" type="integer"/>
            <parameter mode="IN" name="why" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="todo(why text)" returnType="SETOF boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    PERFORM _add('todo', 1, COALESCE(why, ''));
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="why" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="todo(why text, how_many integer)" returnType="SETOF boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    PERFORM _add('todo', COALESCE(how_many, 1), COALESCE(why, ''));
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="why" type="text"/>
            <parameter mode="IN" name="how_many" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="todo_end()" returnType="SETOF boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    id integer;
BEGIN
    id := _get_latest( 'todo', -1 );
    IF id IS NULL THEN
        RAISE EXCEPTION 'todo_end() called without todo_start()';
    END IF;
    EXECUTE 'DELETE FROM __tcache__ WHERE id = ' || id;
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="todo_start()" returnType="SETOF boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    PERFORM _add('todo', -1, '');
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="todo_start(text)" returnType="SETOF boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
    PERFORM _add('todo', -1, COALESCE($1, ''));
    RETURN;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="trigger_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT trigger_is(
        $1, $2, $3,
        'Trigger ' || quote_ident($2) || ' should call ' || quote_ident($3) || '()'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="trigger_is(name, name, name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT trigger_is(
        $1, $2, $3, $4, $5,
        'Trigger ' || quote_ident($3) || ' should call ' || quote_ident($4) || '.' || quote_ident($5) || '()'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="trigger_is(name, name, name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    pname text;
BEGIN
    SELECT quote_ident(ni.nspname) || '.' || quote_ident(p.proname)
      FROM pg_catalog.pg_trigger t
      JOIN pg_catalog.pg_class ct     ON ct.oid = t.tgrelid
      JOIN pg_catalog.pg_namespace nt ON nt.oid = ct.relnamespace
      JOIN pg_catalog.pg_proc p       ON p.oid = t.tgfoid
      JOIN pg_catalog.pg_namespace ni ON ni.oid = p.pronamespace
     WHERE nt.nspname = $1
       AND ct.relname = $2
       AND t.tgname   = $3
      INTO pname;

    RETURN is( pname, quote_ident($4) || '.' || quote_ident($5), $6 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="trigger_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    pname text;
BEGIN
    SELECT p.proname
      FROM pg_catalog.pg_trigger t
      JOIN pg_catalog.pg_class ct ON ct.oid = t.tgrelid
      JOIN pg_catalog.pg_proc p   ON p.oid = t.tgfoid
     WHERE ct.relname = $1
       AND t.tgname   = $2
       AND pg_catalog.pg_table_is_visible(ct.oid)
      INTO pname;

    RETURN is( pname, $3::text, $4 );
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="triggers_are(name, name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT triggers_are( $1, $2, $3, 'Table ' || quote_ident($1) || '.' || quote_ident($2) || ' should have the correct triggers' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="triggers_are(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'triggers',
        ARRAY(
            SELECT t.tgname
              FROM pg_catalog.pg_trigger t
              JOIN pg_catalog.pg_class c     ON c.oid = t.tgrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
             WHERE n.nspname = $1
               AND c.relname = $2
               AND NOT t.tgisinternal
            EXCEPT
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
        ),
        ARRAY(
            SELECT $3[i]
              FROM generate_series(1, array_upper($3, 1)) s(i)
            EXCEPT
            SELECT t.tgname
              FROM pg_catalog.pg_trigger t
              JOIN pg_catalog.pg_class c     ON c.oid = t.tgrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
             WHERE n.nspname = $1
               AND c.relname = $2
               AND NOT t.tgisinternal
        ),
        $4
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="triggers_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT triggers_are( $1, $2, 'Table ' || quote_ident($1) || ' should have the correct triggers' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="triggers_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'triggers',
        ARRAY(
            SELECT t.tgname
              FROM pg_catalog.pg_trigger t
              JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
             WHERE c.relname = $1
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND NOT t.tgisinternal
            EXCEPT
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
        ),
        ARRAY(
            SELECT $2[i]
              FROM generate_series(1, array_upper($2, 1)) s(i)
            EXCEPT
            SELECT t.tgname
              FROM pg_catalog.pg_trigger t
              JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid
              JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
               AND n.nspname NOT IN ('pg_catalog', 'information_schema')
               AND NOT t.tgisinternal
        ),
        $3
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ts_dist(timestamp without time zone, timestamp without time zone)" returnType="interval" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ts_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="timestamp without time zone"/>
            <parameter mode="IN" type="timestamp without time zone"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="tstz_dist(timestamp with time zone, timestamp with time zone)" returnType="interval" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[tstz_dist]]></definition>
         <parameters>
            <parameter mode="IN" type="timestamp with time zone"/>
            <parameter mode="IN" type="timestamp with time zone"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="type_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT type_owner_is(
        $1, $2,
        'Type ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="type_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT type_owner_is(
        $1, $2, $3,
        'Type ' || quote_ident($1) || '.' || quote_ident($2) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="type_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_type_owner($1, $2);
BEGIN
    -- Make sure the type exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    Type ' || quote_ident($1) || '.' || quote_ident($2) || ' not found'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="type_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_type_owner($1);
BEGIN
    -- Make sure the type exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    Type ' || quote_ident($1) || ' not found'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="types_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, 'Schema ' || quote_ident($1) || ' should have the correct types', NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="types_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, $3, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="types_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, 'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct types', NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="types_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _types_are( $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unaccent(regdictionary, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[unaccent_dict]]></definition>
         <parameters>
            <parameter mode="IN" type="regdictionary"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unaccent(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[unaccent_dict]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unaccent_init(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[unaccent_init]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unaccent_lexize(internal, internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[unaccent_lexize]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unalike(anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _unalike( $1 !~~ $2, $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unalike(anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _unalike( $1 !~~ $2, $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unialike(anyelement, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _unalike( $1 !~~* $2, $1, $2, NULL );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unialike(anyelement, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _unalike( $1 !~~* $2, $1, $2, $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="users_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT users_are( $1, 'There should be the correct users' );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="users_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'users',
        ARRAY(
            SELECT usename
              FROM pg_catalog.pg_user
            EXCEPT
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
        ),
        ARRAY(
            SELECT $1[i]
              FROM generate_series(1, array_upper($1, 1)) s(i)
            EXCEPT
            SELECT usename
              FROM pg_catalog.pg_user
        ),
        $2
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v1()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v1]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v1mc()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v1mc]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_generate_v3(namespace uuid, name text)" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v3]]></definition>
         <parameters>
            <parameter mode="IN" name="namespace" type="uuid"/>
            <parameter mode="IN" name="name" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v4()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v4]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_generate_v5(namespace uuid, name text)" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v5]]></definition>
         <parameters>
            <parameter mode="IN" name="namespace" type="uuid"/>
            <parameter mode="IN" name="name" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_nil()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_nil]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_dns()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_ns_dns]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_oid()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_ns_oid]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_url()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_ns_url]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_x500()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_ns_x500]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="view_owner_is(name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT view_owner_is(
        $1, $2,
        'View ' || quote_ident($1) || ' should be owned by ' || quote_ident($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="view_owner_is(name, name, name)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT view_owner_is(
        $1, $2, $3,
        'View ' || quote_ident($1) || '.' || quote_ident($2) || ' should be owned by ' || quote_ident($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="view_owner_is(name, name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('v'::char, $1, $2);
BEGIN
    -- Make sure the view exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $4) || E'\n' || diag(
            E'    View ' || quote_ident($1) || '.' || quote_ident($2) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $3, $4);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="view_owner_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    owner NAME := _get_rel_owner('v'::char, $1);
BEGIN
    -- Make sure the view exists.
    IF owner IS NULL THEN
        RETURN ok(FALSE, $3) || E'\n' || diag(
            E'    View ' || quote_ident($1) || ' does not exist'
        );
    END IF;

    RETURN is(owner, $2, $3);
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="views_are(name, name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'views', _extras('v', $1, $2), _missing('v', $1, $2),
        'Schema ' || quote_ident($1) || ' should have the correct views'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="views_are(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'views', _extras('v', $1, $2), _missing('v', $1, $2), $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="views_are(name[])" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are(
        'views', _extras('v', $1), _missing('v', $1),
        'Search path ' || pg_catalog.current_setting('search_path') || ' should have the correct views'
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="views_are(name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _are( 'views', _extras('v', $1), _missing('v', $1), $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="volatility_is(name, name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT volatility_is(
        $1, $2, $3, $4,
        'Function ' || quote_ident($1) || '.' || quote_ident($2) || '(' ||
        array_to_string($3, ', ') || ') should be ' || _refine_vol($4)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="volatility_is(name, name, name[], text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, $3, _vol($1, $2, $3), _refine_vol($4), $5 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="volatility_is(name, name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT volatility_is(
        $1, $2, $3,
        'Function ' || quote_ident($1) || '.' || quote_ident($2)
        || '() should be ' || _refine_vol($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="volatility_is(name, name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare($1, $2, _vol($1, $2), _refine_vol($3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="volatility_is(name, name[], text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT volatility_is(
        $1, $2, $3,
        'Function ' || quote_ident($1) || '(' ||
        array_to_string($2, ', ') || ') should be ' || _refine_vol($3)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="volatility_is(name, name[], text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, $2, _vol($1, $2), _refine_vol($3), $4 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="name[]"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="volatility_is(name, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT volatility_is(
        $1, $2,
        'Function ' || quote_ident($1) || '() should be ' || _refine_vol($2)
    );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="volatility_is(name, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT _func_compare(NULL, $1, _vol($1), _refine_vol($2), $3 );]]></definition>
         <parameters>
            <parameter mode="IN" type="name"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
   </routines>
</database>
