<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.configuration="org.eventb.core.fwd" version="5">
    <org.eventb.core.refinesMachine name="'" org.eventb.core.target="1-ClassTreeTraversal"/>
    <org.eventb.core.seesContext name="(" org.eventb.core.target="110-MappingContext"/>
    <org.eventb.core.variable name="var2" org.eventb.core.comment="l'association d'une signature à une ou plusieurs classe" org.eventb.core.identifier="signatures"/>
    <org.eventb.core.variable name="var9" org.eventb.core.comment="les expressions définies uniquement selon leurs sous-ensembles" org.eventb.core.identifier="signatureSupersets"/>
    <org.eventb.core.variable name="var8" org.eventb.core.comment="la relation de sous-ensemble entre des signatures" org.eventb.core.identifier="subsets"/>
    <org.eventb.core.variable name="7" org.eventb.core.comment="les éléments qu'il reste à arrimer sur l'étage courant de l'arbre" org.eventb.core.identifier="currentLevel"/>
    <org.eventb.core.variable name="8" org.eventb.core.comment="la classe à arrimer" org.eventb.core.identifier="currentClass"/>
    <org.eventb.core.variable name=";" org.eventb.core.comment="le numéro de l'étage courant" org.eventb.core.identifier="levelNum"/>
    <org.eventb.core.variable name="?" org.eventb.core.comment="l'ensemble des classes arrimées" org.eventb.core.identifier="mapped"/>
    <org.eventb.core.event name="@" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="INITIALISATION">
        <org.eventb.core.action name=")" org.eventb.core.assignment="signatures ≔ ∅" org.eventb.core.label="init_signatures"/>
        <org.eventb.core.action name="act1" org.eventb.core.assignment="signatureSupersets ≔ ∅" org.eventb.core.label="init_signatureSupersets"/>
        <org.eventb.core.action name="*" org.eventb.core.assignment="subsets ≔ ∅" org.eventb.core.label="init_subsets"/>
        <org.eventb.core.action name="internal6" org.eventb.core.assignment="levelNum ≔ max_level" org.eventb.core.label="init_stepNum"/>
        <org.eventb.core.action name="internal8" org.eventb.core.assignment="mapped ≔ ∅" org.eventb.core.label="init_mapped"/>
        <org.eventb.core.action name="(" org.eventb.core.assignment="currentClass, currentLevel, expressionsOfCurrentClass, expressionsLeftForCurrentClass :∣&#10;&#9;currentClass' ∈ c_level[{max_level}] ∧&#10;    currentLevel' = c_level[{max_level}] ∖ { currentClass' } ∧&#10;&#9;(∀e · e ∈ expressionsOfCurrentClass'&#10;       ⇔ individuation[{e}] ≠ ∅ ∧&#10;          (∀p · p ∈ individuation[{e}]&#10;             ⇒ currentClass' ∈ class_of[{p}])) ∧&#10;    expressionsLeftForCurrentClass' = expressionsOfCurrentClass'" org.eventb.core.comment="La classe courante est choisie arbitrairement parmis les classes du niveau&#10;L'expression est choisie arbitrairement parmis les expressions permettant l'individuation des particuliers qui répondent aux axiomes de cette classe&#10;   Si aucune expression ne permet l'individuation de particuliers répondant aux axiomes de la classe, l'expression correspond à l'expression neutre" org.eventb.core.label="init_currentClass"/>
        <org.eventb.core.action name="internal4" org.eventb.core.assignment="currentExpression :∈ E" org.eventb.core.comment="L'expression courante correspond à une expression quelconque" org.eventb.core.label="init_currentExpression"/>
        <org.eventb.core.action name="internal5" org.eventb.core.assignment="analysedExpressions ≔ ∅" org.eventb.core.comment="aucune expression n'est analysée" org.eventb.core.label="init_analysedExpressions"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="A" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="final">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="final"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="lorsque toutes les classes sont arrimées, on sait que toutes les expressions correspondant à des signatures valides ont étés analysées" org.eventb.core.label="final_grd2" org.eventb.core.predicate="∀c · c ∈ C&#10;  ⇒ (∀e · individuation[{e}] ≠ ∅ ∧&#10;           (∀p · p ∈ individuation[{e}]&#10;              ⇔ c ∈ class_of[{p}])&#10;          ⇒ e ↦ c ∈ analysedExpressions)" org.eventb.core.theorem="true"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="B" org.eventb.core.comment="on passe à la prochaine classe" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="next_class">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="next_class"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="l'arrimage est terminé pour la classe en cours" org.eventb.core.label="nextClass_grd1" org.eventb.core.predicate="currentClass ∈ mapped"/>
        <org.eventb.core.guard name="'" org.eventb.core.comment="il reste des classes à arrimer sur cette étage" org.eventb.core.label="nextClass_grd2" org.eventb.core.predicate="currentLevel ≠ ∅"/>
        <org.eventb.core.guard name="grd1" org.eventb.core.comment="on n'a pas appliqué le procédé d'arrimage à toutes les classes" org.eventb.core.label="nextClass_grd3_thm" org.eventb.core.predicate="mapped ≠ C" org.eventb.core.theorem="true"/>
        <org.eventb.core.action name="*" org.eventb.core.assignment="currentClass, currentLevel, expressionsOfCurrentClass, expressionsLeftForCurrentClass :∣&#10;&#9;currentClass' ∈ currentLevel ∧&#10;    currentLevel' = currentLevel ∖ { currentClass' } ∧&#10;&#9;(∀e · e ∈ expressionsOfCurrentClass'&#10;       ⇔ individuation[{e}] ≠ ∅ ∧&#10;          (∀p · p ∈ individuation[{e}]&#10;             ⇒ currentClass' ∈ class_of[{p}])) ∧&#10;    expressionsLeftForCurrentClass' = expressionsOfCurrentClass'" org.eventb.core.comment="on choisi une classe à arrimer&#10;on la retire des classes à arrimer pour ce niveau&#10;on met à jour les expressions correspondant à des signatures valides pour la classe courante" org.eventb.core.label="nextClass_pop"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="C" org.eventb.core.comment="on passe au prochain niveau" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="next_level">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="next_level"/>
        <org.eventb.core.guard name="+" org.eventb.core.comment="l'arrimage est terminé pour la classe en cours" org.eventb.core.label="nextLevel_grd1" org.eventb.core.predicate="currentClass ∈ mapped"/>
        <org.eventb.core.guard name="'" org.eventb.core.comment="il n'y a pas d'autre classes à arrimer à ce niveau" org.eventb.core.label="nextLevel_grd2" org.eventb.core.predicate="currentLevel = ∅"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="on peut encore monter d'un niveau" org.eventb.core.label="nextLevel_grd3" org.eventb.core.predicate="levelNum &gt; 0"/>
        <org.eventb.core.guard name="grd1" org.eventb.core.comment="on n'a pas appliqué le procédé d'arrimage à toutes les classes" org.eventb.core.label="nextLevel_grd4_thm" org.eventb.core.predicate="mapped ≠ C" org.eventb.core.theorem="true"/>
        <org.eventb.core.action name="act1" org.eventb.core.assignment="currentLevel, currentClass, expressionsOfCurrentClass, expressionsLeftForCurrentClass :∣&#10;&#9;currentClass' ∈ c_level[{levelNum − 1}] ∖ mapped ∧&#10;    currentLevel' = (c_level[{levelNum − 1}] ∖ mapped) ∖ { currentClass' } ∧&#10;&#9;(∀e · e ∈ expressionsOfCurrentClass'&#10;       ⇔ individuation[{e}] ≠ ∅ ∧&#10;          (∀p · p ∈ individuation[{e}]&#10;             ⇒ currentClass' ∈ class_of[{p}])) ∧&#10;    expressionsLeftForCurrentClass' = expressionsOfCurrentClass'" org.eventb.core.comment="on choisi une classe à arrimer et on la retire des classes à arrimer pour ce niveau&#10;on met à jour les expressions correspondant à des signatures valides pour la classe courante" org.eventb.core.label="nextClass_popFromNewLevel"/>
        <org.eventb.core.action name="*" org.eventb.core.assignment="levelNum ≔ levelNum − 1" org.eventb.core.comment="le numéro du niveau correpond au numéro du niveau courant" org.eventb.core.label="nextLevel_changeLevelNum"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="evt1" org.eventb.core.comment="l'arrimage de la classe est terminé" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="class_mapped">
        <org.eventb.core.refinesEvent name="(" org.eventb.core.target="class_mapped"/>
        <org.eventb.core.guard name="+" org.eventb.core.comment="toutes les expressions de la classe courante sont analysées" org.eventb.core.label="classMapped_grd3" org.eventb.core.predicate="expressionsOfCurrentClass ⊆ analysedExpressions∼[{currentClass}]"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="H" org.eventb.core.comment="on passe à la prochaine expression" org.eventb.core.convergence="1" org.eventb.core.extended="false" org.eventb.core.label="next_expression">
        <org.eventb.core.guard name="grd4" org.eventb.core.comment="soit la première expression n'est pas analysée,&#10;soit l'analyse de l'expression courante est terminée" org.eventb.core.label="nextExpression_grd1" org.eventb.core.predicate="expressionsLeftForCurrentClass = expressionsOfCurrentClass ∨ &#10;currentExpression ↦ currentClass ∈ analysedExpressions"/>
        <org.eventb.core.guard name="grd2" org.eventb.core.comment="il reste des expressions à taiter pour la classe courante" org.eventb.core.label="nextExpression_grd2" org.eventb.core.predicate="expressionsLeftForCurrentClass ≠ ∅"/>
        <org.eventb.core.guard name="grd5" org.eventb.core.comment="la classe courant n'est pas arrimée" org.eventb.core.label="nextExpression_grd3_thm" org.eventb.core.predicate="currentClass ∉ mapped" org.eventb.core.theorem="true"/>
        <org.eventb.core.guard name="grd6" org.eventb.core.comment="toutes les expressions de la classe courante ne sont pas analysées" org.eventb.core.label="nextExpression_grd4_thm" org.eventb.core.predicate="¬(expressionsOfCurrentClass ⊆ analysedExpressions∼[{currentClass}])" org.eventb.core.theorem="true"/>
        <org.eventb.core.guard name="grd7" org.eventb.core.comment="on n'a pas appliqué le procédé d'arrimage à toutes les classes" org.eventb.core.label="nextExpression_grd5_thm" org.eventb.core.predicate="mapped ≠ C" org.eventb.core.theorem="true"/>
        <org.eventb.core.action name="grd3" org.eventb.core.assignment="currentExpression, expressionsLeftForCurrentClass :∣ currentExpression' ∈ expressionsLeftForCurrentClass  ∧&#10;                                                     expressionsLeftForCurrentClass' = expressionsLeftForCurrentClass ∖ { currentExpression' }" org.eventb.core.comment="on passe à la prochaine expression&#10;on retire l'expression aux expressions à analyser pour la classe courante" org.eventb.core.label="nextExpression_pop"/>
    </org.eventb.core.event>
    <org.eventb.core.variable name="F" org.eventb.core.comment="l'expression en cours d'évaluation" org.eventb.core.identifier="currentExpression"/>
    <org.eventb.core.invariant name="G" org.eventb.core.comment="l'expression courante est une expression" org.eventb.core.label="type_currentExpression" org.eventb.core.predicate="currentExpression ∈ E"/>
    <org.eventb.core.invariant name="var8" org.eventb.core.comment="l'ensemble des expressions à évaluer pour la classe est un sous-ensemble des expressions" org.eventb.core.label="type_expressionsOfCurrentClass" org.eventb.core.predicate="expressionsOfCurrentClass ⊆ E"/>
    <org.eventb.core.invariant name="inv2" org.eventb.core.comment="l'ensemble des expressions à évaluer pour la classe est un sous-ensemble des expressions" org.eventb.core.label="type_expressionsLeftForCurrentClass" org.eventb.core.predicate="expressionsLeftForCurrentClass ⊆ E "/>
    <org.eventb.core.invariant name="varH" org.eventb.core.comment="l'ensembles d'expressions analysées en regard de l'arrimage d'une classe" org.eventb.core.label="type_analysedExpressions" org.eventb.core.predicate="analysedExpressions ∈ E ↔ C"/>
    <org.eventb.core.invariant name="varF" org.eventb.core.comment="une expression de la classe courante correspond à une expression pour laquelle tout les particuliers qu'elle individualisent répondent aux axiomes de la classe courante" org.eventb.core.label="def_expressionsOfCurrentClass" org.eventb.core.predicate="∀e · e ∈ expressionsOfCurrentClass&#10;  ⇔ individuation[{e}] ≠ ∅ ∧&#10;     (∀p · p ∈ individuation[{e}]&#10;        ⇒ currentClass ∈ class_of[{p}])"/>
    <org.eventb.core.variable name="var7" org.eventb.core.comment="les expressions qui permettent l'individuation de particuliers qui répondent aux axiomes de la classe courante" org.eventb.core.identifier="expressionsOfCurrentClass"/>
    <org.eventb.core.variant name="var&gt;" org.eventb.core.comment="next_expression converge en diminuant le nombre d'expressions pour la classe courante" org.eventb.core.expression="card(expressionsLeftForCurrentClass)" org.eventb.core.label="var_nextExpression"/>
    <org.eventb.core.invariant name="varN" org.eventb.core.comment="les expressions à analyser sont des expressions de la classe courante" org.eventb.core.label="def_expressionsLeftForCurrentClass" org.eventb.core.predicate="expressionsLeftForCurrentClass ⊆ expressionsOfCurrentClass"/>
    <org.eventb.core.invariant name="var?" org.eventb.core.comment="tout les particuliers individualisés par l'expression courante respectent les axiomes de la classe courante" org.eventb.core.label="inv_particularOfExpressionsOfCurrentClassHasClassOfCurrentClass" org.eventb.core.predicate="∀p · p ∈ individuation[expressionsOfCurrentClass]&#10;  ⇒ currentClass ∈ class_of[{p}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.variable name="varE" org.eventb.core.comment="les expressions encore à analyser pour la classe courante " org.eventb.core.identifier="expressionsLeftForCurrentClass"/>
    <org.eventb.core.variable name="varG" org.eventb.core.comment="l'ensemble des expressions analysées" org.eventb.core.identifier="analysedExpressions"/>
    <org.eventb.core.invariant name="varL" org.eventb.core.comment="les expressions analysées sont marquée comme telle" org.eventb.core.label="inv_allExpressionOfCurrentClassNotLeftAreAnalysed" org.eventb.core.predicate="∀e · e ∈ expressionsOfCurrentClass ∧&#10;     e ∉ expressionsLeftForCurrentClass ∪ { currentExpression }&#10;  ⇒ e ↦ currentClass ∈ analysedExpressions"/>
    <org.eventb.core.invariant name="varM" org.eventb.core.comment="les expressions marquée comme analysée ne sont plus dans la liste des expressions à analyser " org.eventb.core.label="inv_analysedExpressionAreNotLeftForCurrentClass" org.eventb.core.predicate="∀e · e ↦ currentClass ∈ analysedExpressions &#10;  ⇒ e ∈ expressionsOfCurrentClass ∧&#10;     e ∉ expressionsLeftForCurrentClass"/>
    <org.eventb.core.invariant name="varJ" org.eventb.core.comment="toutes les expressions qui correspondent à des signatures valides sont analysées pour les classes arrimées" org.eventb.core.label="inv_allValidExpressionsAreAnalysedForMappedClasses" org.eventb.core.predicate="(∀c · c ∈ mapped&#10;   ⇒ (∀e · individuation[{e}] ≠ ∅ ∧ &#10;            (∀p · p ∈ individuation[{e}]&#10;               ⇔ c ∈ class_of[{p}])&#10;         ⇒ e ↦ c ∈ analysedExpressions))"/>
    <org.eventb.core.event name="varK" org.eventb.core.comment="l'analyse de l'expression est terminée" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="expression_analysed">
        <org.eventb.core.guard name="'" org.eventb.core.comment="l'expression n'est pas déjà marquée comme analysée" org.eventb.core.label="expressionAnalysed_grd1" org.eventb.core.predicate="currentExpression ↦ currentClass ∉ analysedExpressions"/>
        <org.eventb.core.action name="(" org.eventb.core.assignment="analysedExpressions ≔ analysedExpressions ∪ { currentExpression ↦ currentClass }" org.eventb.core.comment="on ajoute l'expression aux expressions analysées" org.eventb.core.label="expressionAnalysed_addToAnalysed"/>
        <org.eventb.core.guard name=")" org.eventb.core.comment="l'expression courante correspond bel et bien à une expression de la classe" org.eventb.core.label="expressionAnalysed_grd2" org.eventb.core.predicate="currentExpression ∈ expressionsOfCurrentClass"/>
        <org.eventb.core.guard name="*" org.eventb.core.comment="l'expression courante n'est plus dans les expressions à analyser" org.eventb.core.label="expressionAnalysed_grd3" org.eventb.core.predicate="currentExpression ∉ expressionsLeftForCurrentClass"/>
        <org.eventb.core.guard name="grd1" org.eventb.core.comment="la classe courant n'est pas arrimée" org.eventb.core.label="expressionAnalysed_grd4_thm" org.eventb.core.predicate="currentClass ∉ mapped" org.eventb.core.theorem="true"/>
        <org.eventb.core.guard name="grd2" org.eventb.core.comment="toutes les expressions de la classe courante ne sont pas analysées" org.eventb.core.label="expressionAnalysed_grd5_thm" org.eventb.core.predicate="¬(expressionsOfCurrentClass ⊆ analysedExpressions∼[{currentClass}])" org.eventb.core.theorem="true"/>
        <org.eventb.core.guard name="grd3" org.eventb.core.comment="on n'a pas appliqué le procédé d'arrimage à toutes les classes" org.eventb.core.label="expressionAnalysed_grd6_thm" org.eventb.core.predicate="mapped ≠ C" org.eventb.core.theorem="true"/>
    </org.eventb.core.event>
    <org.eventb.core.invariant name="varO" org.eventb.core.comment="seuls les expressions de la classe courante et des classes arrimées peuvent être être marquées comme analysées " org.eventb.core.label="inv_allExpressionsOfNonVisitedClassAreNotMarkedAsAnalysed" org.eventb.core.predicate="analysedExpressions∼[C ∖ (mapped ∪ {currentClass})] = ∅"/>
    <org.eventb.core.invariant name="inv3" org.eventb.core.comment="les expressions valides pour la classe courante individualisent tous au moins un particulier" org.eventb.core.label="inv_expressionsOfCurrentClassIndividuatesAtLeastAParticular" org.eventb.core.predicate="∀e · e ∈ expressionsOfCurrentClass &#10;  ⇒ individuation[{e}] ≠ ∅" org.eventb.core.theorem="true"/>
    <org.eventb.core.invariant name="varP" org.eventb.core.comment="la classe courante n'est pas considérée arrimée tant qu'il reste des expressions à analyser" org.eventb.core.label="inv_expressionAreTreatedForMapped" org.eventb.core.predicate="expressionsLeftForCurrentClass ≠ ∅ ⇒ currentClass ∉ mapped"/>
    <org.eventb.core.invariant name="inv4" org.eventb.core.comment="la classe courante n'est pas considérée arrimée tant que l'expression courante n'est pas analysée, si elle fait partie des expressions de la classe" org.eventb.core.label="inv_currentExpressionIsTreatedForMapped" org.eventb.core.predicate="currentExpression ∈ expressionsOfCurrentClass ∧ &#10;currentExpression ↦ currentClass ∉ analysedExpressions ⇒ currentClass ∉ mapped"/>
</org.eventb.core.machineFile>
