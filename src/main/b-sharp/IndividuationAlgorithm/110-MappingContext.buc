<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.contextFile org.eventb.core.configuration="org.eventb.core.fwd;de.prob.symbolic.ctxBase" version="3">
    <org.eventb.core.extendsContext name="'" org.eventb.core.target="040-OntologyContext_Particulars"/>
    <org.eventb.core.carrierSet name=")" org.eventb.core.comment="l'ensemble des expressions de la source de données" org.eventb.core.identifier="E"/>
    <org.eventb.core.axiom name="cst7" org.eventb.core.comment="E est un ensemble fini" org.eventb.core.label="map_finite_E" org.eventb.core.predicate="finite(E)"/>
    <org.eventb.core.constant de.prob.symbolic.symbolicAttribute="false" name="," org.eventb.core.comment="les particuliers individualisés par l'expression" org.eventb.core.identifier="individuation"/>
    <org.eventb.core.axiom name="cst?" org.eventb.core.comment="K est un ensemble fini" org.eventb.core.label="map_finite_K" org.eventb.core.predicate="finite(K)"/>
    <org.eventb.core.axiom name="-" org.eventb.core.comment="relation surjective des expressions vers les particuliers dont elles permettent l'individuation" org.eventb.core.label="map_type_individuation" org.eventb.core.predicate="individuation ∈ E  P"/>
    <org.eventb.core.axiom name="axm1" org.eventb.core.comment="relation entre une expression e1 et une expression e2, avec les particuliers individualisés par e1 qui sont également individualisés par e2  " org.eventb.core.label="map_type_expSubsets" org.eventb.core.predicate="exp_subsets ∈ E ↔ E"/>
    <org.eventb.core.axiom name="axm2" org.eventb.core.comment="relation entre une première expression et une seconde expression qui individualise tous les particuliers individualisés par la première " org.eventb.core.label="map_type_expEquivalent" org.eventb.core.predicate="exp_equivalent ∈ E ↔ E"/>
    <org.eventb.core.constant de.prob.symbolic.symbolicAttribute="false" name="cst1" org.eventb.core.comment="les particuliers individualisés par une expression sont aussi individualisés par ces expressions (e1 ∈ exp_subsets[{e2}]: e1 est un sous-ensemble de e2)" org.eventb.core.identifier="exp_subsets"/>
    <org.eventb.core.constant de.prob.symbolic.symbolicAttribute="false" name="cst2" org.eventb.core.comment="tous les particuliers individualisés par l'expression sont aussi individualisés par ces expressions" org.eventb.core.identifier="exp_equivalent"/>
    <org.eventb.core.axiom name="cst4" org.eventb.core.comment="relation entre des expressions qui se chevauchent, c'est-à-dire qu'il y a intersection de leurs particuliers" org.eventb.core.label="map_type_expOverlap" org.eventb.core.predicate="exp_overlap ∈ E ↔ E"/>
    <org.eventb.core.axiom name="cstA" org.eventb.core.comment="fonction surjective entre une expression et sa clé" org.eventb.core.label="map_type_expKey" org.eventb.core.predicate="exp_key ∈ E ↠ K"/>
    <org.eventb.core.axiom name="cstG" org.eventb.core.comment="relation entre plusieurs clés qui sont notées comme compatibles" org.eventb.core.label="map_type_compatibleKey" org.eventb.core.predicate="key_compatible ∈ K ↔ K"/>
    <org.eventb.core.axiom name="cstR" org.eventb.core.comment="fonction bijective entre la numérotation de la liste et les éléments de E" org.eventb.core.label="map_type_expList" org.eventb.core.predicate="exp_list ∈ 1‥card(E) ⤖ E"/>
    <org.eventb.core.axiom name="axm11" org.eventb.core.comment="tout sous-ensemble de P est représenté par au moins une expression" org.eventb.core.label="map_individuation_def" org.eventb.core.predicate="∀PSet · PSet ∈ ℙ(P) &#10;     ⇒ (∃e · individuation[{e}] = PSet)"/>
    <org.eventb.core.axiom name="axm3" org.eventb.core.comment="une expression e1 est sous-ensemble d'une expression e2 si l'ensemble de particuliers de e1 est un sous-ensemble de l'ensemble de particuliers de e2" org.eventb.core.label="map_expSubsets_def" org.eventb.core.predicate="∀e1,e2 · {e1,e2} ⊆ E ∧&#10;         e1 ∈ exp_subsets[{e2}] &#10;      ⇔ &#10;         individuation[{e1}] ⊆ individuation[{e2}]"/>
    <org.eventb.core.axiom name="cstU" org.eventb.core.comment="exp_subsets est une relation réflexive" org.eventb.core.label="map_expSubsets_thm_reflexive" org.eventb.core.predicate="∀e · e ∈ E ⇒ e ∈ exp_subsets[{e}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cstV" org.eventb.core.comment="exp_subsets est une relation transitive" org.eventb.core.label="map_expSubsets_thm_transitive" org.eventb.core.predicate="∀e1,e2,e3 · e1 ∈ exp_subsets[{e2}] ∧ &#10;            e2 ∈ exp_subsets[{e3}]&#10;         ⇒ e1 ∈ exp_subsets[{e3}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cst5" org.eventb.core.comment="une expression e1 overlap une expression e2 si l'intersection des particuliers qu'ils individualisent n'est pas vide ou si une des deux expressions n'individualise aucun particulier" org.eventb.core.label="map_expOverlap_def" org.eventb.core.predicate="∀e1,e2 · {e1,e2} ⊆ E ∧&#10;         e1 ∈ exp_overlap[{e2}] &#10;      ⇔ (individuation[{e1}] ∩ individuation[{e2}]) ≠ ∅ ∨ &#10;          individuation[{e1}] = ∅ ∨ &#10;          individuation[{e2}] = ∅"/>
    <org.eventb.core.axiom name="axm10" org.eventb.core.comment="deux expressions non vide s'overlap si l'intersection des particuliers qu'ils individualisent n'est pas vide" org.eventb.core.label="map_expOverlap_thm_nonEmpty" org.eventb.core.predicate="∀e1,e2 · {e1,e2} ⊆ E ∧&#10;         e1 ∈ exp_overlap[{e2}] ∧&#10;         individuation[{e1}] ≠ ∅ ∧&#10;         individuation[{e2}] ≠ ∅&#10;      ⇔ (individuation[{e1}] ∩ individuation[{e2}]) ≠ ∅" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cstW" org.eventb.core.comment="exp_overlap est une relation réflexive" org.eventb.core.label="map_expOverlap_thm_reflevive" org.eventb.core.predicate="∀e · e ∈ E ⇒ e ∈ exp_overlap[{e}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="axm12" org.eventb.core.comment="exp_overlap est une relation symétrique" org.eventb.core.label="map_expOverlap_thm_symmetric" org.eventb.core.predicate="∀e1,e2 · e1 ∈ exp_overlap[{e2}]&#10;      ⇒ e2 ∈ exp_overlap[{e1}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cstS" org.eventb.core.comment="deux expressions qui sont en relation de sous-ensembles s'overlap" org.eventb.core.label="map_expSubsets_thm_expSubsetsOverlaps" org.eventb.core.predicate="∀e1,e2 · e1 ∈ exp_subsets[{e2}]&#10;      ⇒ e1 ∈ exp_overlap[{e2}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cstK" org.eventb.core.comment="toutes expressions partageant des particuliers peuvent être composées par une sous-expression" org.eventb.core.label="map_expSubsets_thm_intersection" org.eventb.core.predicate="∀e1,e2,p · p ∈ individuation[{e1}] ∩ individuation[{e2}]&#10;        ⇒ (∃e · p ∈ individuation[{e}] ∧&#10;                 e ∈ exp_subsets[{e1}] ∧&#10;                 e ∈ exp_subsets[{e2}])" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cstO" org.eventb.core.comment="puisque toute expression est divisible, il existe une expression permettant l'individuation des particuliers de façon unitaire" org.eventb.core.label="map_expSubsets_thm_max_decomposition" org.eventb.core.predicate="∀p · p ∈ P&#10;  ⇒ (∃e · {p} = individuation[{e}])" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cstP" org.eventb.core.comment="toute expression permettant l'individuation de plus d'un particulier peut être décomposée" org.eventb.core.label="map_expSubsets_thm_decomposition" org.eventb.core.predicate="∀e,p · e ∈ E ∧ &#10;       {p} ⊂ individuation[{e}] &#10;    ⇒ (∃e' · individuation[{e'}] ⊂ individuation[{e}] ∧&#10;              p ∈ individuation[{e'}])" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cstD" org.eventb.core.comment="pour chaque pair d'expressions qui se chevauchent il existe une expression permettant d'individualiser l'union des particuliers de ces expressions " org.eventb.core.label="map_expSubsets_thm_allTwoExpressionHasUnionExpression" org.eventb.core.predicate="∀e1, e2 · e1 ∈ exp_overlap[{e2}]&#10;       ⇒ (∃e3 · e1 ∈ exp_subsets[{e3}] ∧&#10;                 e2 ∈ exp_subsets[{e3}])" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="axm4" org.eventb.core.comment="deux expressions sont équivalentes si leurs ensembles de particuliers sont sous-ensembles" org.eventb.core.label="map_equivalent_def" org.eventb.core.predicate="∀e1,e2 · {e1,e2} ⊆ E ∧&#10;         e2 ∈ exp_equivalent[{e1}] &#10;      ⇔ &#10;         e1 ∈ exp_subsets[{e2}] ∧ e2 ∈ exp_subsets[{e1}]"/>
    <org.eventb.core.axiom name="axm5" org.eventb.core.comment="exp_equivalent est symétrique" org.eventb.core.label="map_equivalent_thm_symmetric" org.eventb.core.predicate="∀e1,e2 · {e1,e2} ⊆ E ∧&#10;         e2 ∈ exp_equivalent[{e1}] &#10;      ⇔ &#10;         e1 ∈ exp_equivalent[{e2}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="axm6" org.eventb.core.comment="exp_equivalent est réflexif" org.eventb.core.label="map_equivalent_thm_reflexive" org.eventb.core.predicate="∀e·e ∈ E ⇒ e ∈ exp_equivalent[{e}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.constant de.prob.symbolic.symbolicAttribute="false" name="cst3" org.eventb.core.comment="certains particuliers individualisés par une expression sont individualisés par d'autres expressions" org.eventb.core.identifier="exp_overlap"/>
    <org.eventb.core.constant de.prob.symbolic.symbolicAttribute="false" name="cst@" org.eventb.core.comment="relation entre une expression et sa clé" org.eventb.core.identifier="exp_key"/>
    <org.eventb.core.axiom name="cstT" org.eventb.core.comment="exp_equivalent est transitif" org.eventb.core.label="map_equivalent_thm_transitive" org.eventb.core.predicate="∀e1,e2,e3 · {e1,e2,e3} ⊆ E ∧&#10;            e1 ∈ exp_equivalent[{e2}] ∧&#10;            e2 ∈ exp_equivalent[{e3}]&#10;         ⇒ e1 ∈ exp_equivalent[{e3}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cst=" org.eventb.core.comment="une expression n'individuant aucun particulier est un sous-ensemble de toutes les expressions " org.eventb.core.label="map_neutralExpression_thm_subsetsAllExpression" org.eventb.core.predicate="∀e, empty_e · e ∈ E ∧&#10;              empty_e ∈ E ∧&#10;              individuation[{empty_e}] = ∅  &#10;           ⇒ empty_e ∈ exp_subsets[{e}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="cstC" org.eventb.core.comment="pour chaque classe, il existe un ensemble d'expression qui permet l'individuation des particuliers stricts de cette classe" org.eventb.core.label="map_individuation_axm_allClassesHasExpression" org.eventb.core.predicate="∀c · c ∈ C &#10;  ⇒ (∃ SE · (∀p · c ∈ class_of_strict[{p}] &#10;                ⇔ p ∈ individuation[SE]))" org.eventb.core.theorem="true"/>
    <org.eventb.core.carrierSet name="cst&gt;" org.eventb.core.comment="l'ensemble des clés des expressions (composants de signature, une clé peut être composée de plusieurs composants)" org.eventb.core.identifier="K"/>
    <org.eventb.core.axiom name="cstH" org.eventb.core.comment="une clé est nécessairement compatible avec elle-même" org.eventb.core.label="map_keyCompatible_axm_reflexive" org.eventb.core.predicate="∀k · k ∈ K&#10;  ⇒ k ∈ key_compatible[{k}]"/>
    <org.eventb.core.axiom name="cstI" org.eventb.core.comment="la relation key_compatibleest symétrique" org.eventb.core.label="map_keyCompatible_axm_symmetric" org.eventb.core.predicate="∀k1,k2 · {k1,k2} ⊆ K ∧&#10;         k1 ∈ key_compatible[{k2}]&#10;      ⇒ k2 ∈ key_compatible[{k1}]"/>
    <org.eventb.core.axiom name="axm8" org.eventb.core.comment=" relation key_compatible est transitive" org.eventb.core.label="map_keyCompatible_axm_transitive" org.eventb.core.predicate="∀k1,k2,k3 · {k1,k2,k3} ⊆ K ∧&#10;            k1 ∈ key_compatible[{k2}] ∧&#10;            k2 ∈ key_compatible[{k3}] &#10;         ⇒ k1 ∈ key_compatible[{k3}]"/>
    <org.eventb.core.axiom name="axm7" org.eventb.core.comment="pour chaque paire d'expression qui se chevauche, sans qu'un soit le sous-ensemble de l'autre, si leurs clés sont compatibles il existe une expression permettant d'individualiser l'union des particuliers de ces expressions dont la clé est compatible avec celles des autres" org.eventb.core.label="map_expSubsets_axm_expressionsWithCompatibleKeyHasUnionExpressionWithCompatibleKey" org.eventb.core.predicate="∀e1, e2 · e1 ∈ exp_overlap[{e2}] ∧&#10;          e1 ∉ exp_subsets[{e2}] ∧&#10;          e2 ∉ exp_subsets[{e1}] ∧&#10;          exp_key(e1) ∈ key_compatible[{exp_key(e2)}]&#10;       ⇒ (∃e3 · e1 ∈ exp_subsets[{e3}] ∧&#10;                 e2 ∈ exp_subsets[{e3}] ∧&#10;                 exp_key(e3) ∈ key_compatible[{exp_key(e1)}] ∧&#10;                 exp_key(e3) ∈ key_compatible[{exp_key(e2)}])"/>
    <org.eventb.core.constant de.prob.symbolic.symbolicAttribute="false" name="cstF" org.eventb.core.comment="la relation entre deux clés compatibles" org.eventb.core.identifier="key_compatible"/>
    <org.eventb.core.constant de.prob.symbolic.symbolicAttribute="false" name="cstQ" org.eventb.core.comment="la liste de toutes les expressions, dans un ordre quelconque (utilisé pour certaines preuves, utile pour relever une assignation arbitraire)" org.eventb.core.identifier="exp_list"/>
</org.eventb.core.contextFile>
