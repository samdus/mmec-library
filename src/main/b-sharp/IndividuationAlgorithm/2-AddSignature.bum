<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.configuration="org.eventb.core.fwd" version="5">
    <org.eventb.core.refinesMachine name="'" org.eventb.core.target="1-ClassTreeTraversal"/>
    <org.eventb.core.seesContext name="(" org.eventb.core.target="110-MappingContext"/>
    <org.eventb.core.variable name="var2" org.eventb.core.comment="l'association d'une signature à une ou plusieurs classe" org.eventb.core.identifier="signatures"/>
    <org.eventb.core.variable name="var8" org.eventb.core.comment="la relation de sous-ensemble entre des signatures" org.eventb.core.identifier="subsets"/>
    <org.eventb.core.variable name="7" org.eventb.core.comment="les éléments qu'il reste à arrimer sur l'étage courant de l'arbre" org.eventb.core.identifier="currentLevel"/>
    <org.eventb.core.variable name="8" org.eventb.core.comment="la classe à arrimer" org.eventb.core.identifier="currentClass"/>
    <org.eventb.core.variable name=";" org.eventb.core.comment="le numéro de l'étage courant" org.eventb.core.identifier="levelNum"/>
    <org.eventb.core.variable name="?" org.eventb.core.comment="l'ensemble des classes arrimées" org.eventb.core.identifier="mapped"/>
    <org.eventb.core.event name="@" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="INITIALISATION">
        <org.eventb.core.action name=")" org.eventb.core.assignment="signatures ≔ ∅" org.eventb.core.label="init_signatures"/>
        <org.eventb.core.action name="internal1" org.eventb.core.assignment="levelNum ≔ max_level" org.eventb.core.label="init_stepNum"/>
        <org.eventb.core.action name="'" org.eventb.core.assignment="currentLevel ≔ c_level[{max_level}]" org.eventb.core.label="init_step"/>
        <org.eventb.core.action name="internal3" org.eventb.core.assignment="mapped ≔ ∅" org.eventb.core.label="init_mapped"/>
        <org.eventb.core.action name="act3" org.eventb.core.assignment="subsets ≔ ∅" org.eventb.core.label="init_subsets"/>
        <org.eventb.core.action name="(" org.eventb.core.assignment="currentClass, expressionsOfCurrentClass, expressionsLeftForCurrentClass, currentExpression :∣&#10;&#9;currentClass' ∈ c_level[{max_level}] ∧&#10;&#9;(∀p,e · currentClass' ∈ class_of[{p}] ∧&#10;            p ∈ individuation[{e}]&#10;         ⇔ e ∈ expressionsOfCurrentClass') ∧&#10;&#9;(currentExpression' ∈ expressionsOfCurrentClass' ∨ (expressionsOfCurrentClass' = ∅ ∧ currentExpression' = neutral_expression)) ∧&#10;    expressionsLeftForCurrentClass' = expressionsOfCurrentClass' ∖ {currentExpression'}" org.eventb.core.comment="La classe courante est choisie arbitrairement parmis les classes du niveau&#10;L'expression est choisie arbitrairement parmis les expressions permettant l'individuation des particuliers qui répondent aux axiomes de cette classe&#10;   Si aucune expression ne permet l'individuation de particuliers répondant aux axiomes de la classe, l'expression correspond à l'expression neutre" org.eventb.core.label="init_currentClass"/>
        <org.eventb.core.action name="act2" org.eventb.core.assignment="signatureForClasses ≔ ∅" org.eventb.core.label="init_signatureForClasses"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="A" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="final">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="final"/>
        <org.eventb.core.guard name="'" org.eventb.core.comment="on a appliqué le procédé d'arrimage à toutes les classes" org.eventb.core.label="final_grd1" org.eventb.core.predicate="mapped = C"/>
        <org.eventb.core.action name="+" org.eventb.core.assignment="signatures ≔ signatureForClasses" org.eventb.core.label="final_signatures"/>
        <org.eventb.core.action name="act1" org.eventb.core.assignment="subsets :∣ ∀e1,e2 · e1 ∈ dom(signatures) ∧ &#10;                    e2 ∈ dom(signatures) ∧&#10; &#9;&#9;&#9;&#9;&#9;e1 ≠ e2 ∧&#10;                    e1 ∈ exp_overlap[{e2}] &#10;                 ⇒ (∃s,n · n ∈ ℕ1 ∧ &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;s ∈ 0‥n → E ∧&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;(∀i · i ∈ 0‥n−1 ⇒ s(i) ∈ subsets'[{s(i+1)}]) ∧ &#10;&#9;&#9;&#9;&#9;&#9;&#9;    {e1, e2} ⊆ ran(s) &#10;&#9;&#9;&#9;&#9;&#9;)" org.eventb.core.comment="deux signatures distinctes qui individuent des particuliers en commun sont explicitement liés par la relation subsets" org.eventb.core.label="final_subsets"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="B" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="next_class">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="next_class"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="l'arrimage est terminé pour la classe en cours" org.eventb.core.label="nextClass_grd1" org.eventb.core.predicate="currentClass ∈ mapped"/>
        <org.eventb.core.guard name="'" org.eventb.core.comment="il reste des classes à arrimer sur cette étage" org.eventb.core.label="nextClass_grd2" org.eventb.core.predicate="currentLevel ≠ ∅"/>
        <org.eventb.core.action name="*" org.eventb.core.assignment="currentClass, currentLevel, expressionsOfCurrentClass, expressionsLeftForCurrentClass, currentExpression :∣&#10;&#9;currentClass' ∈ currentLevel ∧&#10;    currentLevel' = currentLevel ∖ { currentClass' } ∧&#10;&#9;(∀p,e · currentClass' ∈ class_of[{p}] ∧&#10;            p ∈ individuation[{e}]&#10;         ⇔ e ∈ expressionsOfCurrentClass') ∧&#10;&#9;(currentExpression' ∈ expressionsOfCurrentClass' ∨ (expressionsOfCurrentClass' = ∅ ∧ currentExpression' = neutral_expression)) ∧&#10;    expressionsLeftForCurrentClass' = expressionsOfCurrentClass' ∖ {currentExpression'}" org.eventb.core.comment="on choisi une classe à arrimer&#10;on la retire des classes à arrimer pour ce niveau&#10;on met à jour les signatures pour la classe courante&#10;on choisi une signature à spécifier" org.eventb.core.label="nextClass_pop"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="C" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="next_level">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="next_level"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="H" org.eventb.core.comment="on passe à la prochaine expression" org.eventb.core.convergence="1" org.eventb.core.extended="false" org.eventb.core.label="next_expression">
        <org.eventb.core.guard name="grd2" org.eventb.core.comment="il reste des expressions à taiter" org.eventb.core.label="nextExpression_grd1" org.eventb.core.predicate="expressionsOfCurrentClass ≠ ∅"/>
        <org.eventb.core.guard name="grd1" org.eventb.core.comment="les particuliers individualisés par l'expression courante sont individualisés par une expression assertée comme signature pour la classe courante ou sa descendance" org.eventb.core.label="nextExpression_grd2" org.eventb.core.predicate="∀p,descendants · p ∈ individuation[{currentExpression}] ∧&#10;                 descendants = is_a∼[{currentClass}]&#10;              ⇒ p ∈ individuation[signatureForClasses∼[descendants]]"/>
        <org.eventb.core.action name="grd3" org.eventb.core.assignment="currentExpression, expressionsLeftForCurrentClass :∣ currentExpression' ∈ expressionsLeftForCurrentClass  ∧&#10;                                                     expressionsLeftForCurrentClass' = expressionsLeftForCurrentClass ∖ { currentExpression' }" org.eventb.core.comment="on ajoute la signature aux signatures de la classe courante&#10;on passe à la prochaine expression, s'il y en a une" org.eventb.core.label="nextExpression_pop"/>
    </org.eventb.core.event>
    <org.eventb.core.variable name="var:" org.eventb.core.comment="les signatures assertées pour chaque classes" org.eventb.core.identifier="signatureForClasses"/>
    <org.eventb.core.variable name="F" org.eventb.core.comment="l'expression en cours d'évaluation" org.eventb.core.identifier="currentExpression"/>
    <org.eventb.core.invariant name="G" org.eventb.core.comment="l'expression courante est une expression" org.eventb.core.label="type_currentExpression" org.eventb.core.predicate="currentExpression ∈ E"/>
    <org.eventb.core.invariant name="inv1" org.eventb.core.comment="signatureForClasses doit correspondre à la relation entre une expression et les classes dont l'expression asserte qu'elle sert à l'individuation de particuliers" org.eventb.core.label="type_signatureForClasses" org.eventb.core.predicate="signatureForClasses ∈ E ∖ { neutral_expression } ↔ C"/>
    <org.eventb.core.event name="varA" org.eventb.core.comment="l'expression est identifiée comme une signature à asserter pour la classe" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="expression_isSign">
        <org.eventb.core.guard name="grd2" org.eventb.core.comment="l'expression n'a pas déjà été assertée pour cette classe" org.eventb.core.label="expressionMapped_grd1" org.eventb.core.predicate="currentExpression ↦ currentClass ∉ signatureForClasses"/>
        <org.eventb.core.action name="grd3" org.eventb.core.assignment="signatureForClasses ≔ signatureForClasses ∪ { currentExpression ↦ currentClass }" org.eventb.core.label="expressionMapped_addToSign"/>
        <org.eventb.core.guard name="grd4" org.eventb.core.comment="l'expression ne correspond pas à l'expression neutre" org.eventb.core.label="expressionMapped_grd2" org.eventb.core.predicate="currentExpression ≠ neutral_expression"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="evt1" org.eventb.core.comment="l'arrimage de la classe est terminé" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="class_mapped">
        <org.eventb.core.refinesEvent name="(" org.eventb.core.target="class_mapped"/>
        <org.eventb.core.guard name="*" org.eventb.core.comment="toutes les signatures qui permettent l'individuation de particuliers répondant aux axiomes de la classe ont été traitées " org.eventb.core.label="classMapped_grd2" org.eventb.core.predicate="expressionsLeftForCurrentClass = ∅"/>
    </org.eventb.core.event>
    <org.eventb.core.invariant name="var8" org.eventb.core.comment="l'ensemble des expressions à évaluer pour la classe est un sous-ensemble des expressions" org.eventb.core.label="type_expressionsOfCurrentClass" org.eventb.core.predicate="expressionsOfCurrentClass ⊆ E ∖ { neutral_expression }"/>
    <org.eventb.core.invariant name="inv2" org.eventb.core.comment="l'ensemble des expressions à évaluer pour la classe est un sous-ensemble des expressions" org.eventb.core.label="type_expressionsLeftForCurrentClass" org.eventb.core.predicate="expressionsLeftForCurrentClass ⊆ E  ∖ { neutral_expression }"/>
    <org.eventb.core.invariant name="varF" org.eventb.core.comment="une expression de la classe courante correspond à une expression pour laquelle tout les particuliers qu'elle individualisent répondent aux axiomes de la classe courante" org.eventb.core.label="def_expressionsOfCurrentClass" org.eventb.core.predicate="∀p,e · currentClass ∈ class_of[{p}] ∧&#10;       p ∈ individuation[{e}]&#10;   ⇔ e ∈ expressionsOfCurrentClass"/>
    <org.eventb.core.invariant name="varC" org.eventb.core.comment="l'expression neutre n'est jamais utilisée comme signature" org.eventb.core.label="inv_doNotAddNeutralExpression" org.eventb.core.predicate="neutral_expression ∉ dom(signatureForClasses)" org.eventb.core.theorem="true"/>
    <org.eventb.core.invariant name="var@" org.eventb.core.comment="une signature valide correspond à une expression pour laquelle tout particulier qu'elle individualise respectent les axiomes de la classe pour laquelle la signature a été spécifiée" org.eventb.core.label="inv_allMappedSignAreValid" org.eventb.core.predicate="∀ s,c · s ↦ c ∈ signatureForClasses &#10;     ⇒ (∀p · p ∈ individuation[{s}]&#10;           ⇔ c ∈ class_of[{p}])"/>
    <org.eventb.core.invariant name="var6" org.eventb.core.comment="pour chaque classe arrimée, les particuliers doivent être individualisés par une expression de signature associée à la classe ou un de ses descendants" org.eventb.core.label="inv_allSignOfMapped" org.eventb.core.predicate="∀c, descendants · c ∈ mapped ∧ &#10;                  descendants = is_a∼[{c}]&#10;               ⇒ class_of∼[{c}] ⊆ individuation[signatureForClasses∼[descendants]]"/>
    <org.eventb.core.variable name="var7" org.eventb.core.comment="les expressions qui permettent l'individuation de particuliers qui répondent aux axiomes de la classe courante" org.eventb.core.identifier="expressionsOfCurrentClass"/>
    <org.eventb.core.invariant name="varD" org.eventb.core.comment="tout particuliers de la classe courante qui ne sont pas individualisés par les expressions à analyser sont individualisés par une expression de signature associée à la classe ou un de ses descendants" org.eventb.core.label="inv_allSignOfCurrentClass" org.eventb.core.predicate="∀p,descendants · p ∈ class_of∼[{currentClass}] ∧&#10;                 p ∉ individuation[expressionsLeftForCurrentClass ∪ { currentExpression }] ∧&#10;                 descendants = is_a∼[{currentClass}]&#10;              ⇒ p ∈ individuation[signatureForClasses∼[descendants]]"/>
    <org.eventb.core.invariant name="var=" org.eventb.core.comment="l'expression courante correspond à l'expression neutre uniquement lorsqu'il n'y a plus d'expression à traiter pour la classe" org.eventb.core.label="inv_currentClassIsNeutralOnlyWhenLastExpression" org.eventb.core.predicate="currentExpression = neutral_expression ⇔ expressionsOfCurrentClass = ∅"/>
    <org.eventb.core.variant name="var&gt;" org.eventb.core.comment="next_expression converge en diminuant le nombre d'expressions pour la classe courante" org.eventb.core.expression="card(expressionsOfCurrentClass)" org.eventb.core.label="var_nextExpression"/>
    <org.eventb.core.invariant name="var?" org.eventb.core.comment="tout les particuliers individualisés par l'expression courante respectent les axiomes de la classe courante" org.eventb.core.label="inv_particularOfCurrentExpressionRespectCurrentClass" org.eventb.core.predicate="∀p · p ∈ individuation[expressionsOfCurrentClass]&#10;  ⇒ currentClass ∈ class_of[{p}]" org.eventb.core.theorem="true"/>
    <org.eventb.core.invariant name="varB" org.eventb.core.comment="chaque particulier individualisé par une signature doit être individualisé par une expression associée à sa classe la plus spécifique" org.eventb.core.label="inv_newSignIsntTooCloseOfThing" org.eventb.core.predicate="∀p,c · c ∈ mapped ∧&#10;       c ∈ class_of[{p}] ∧&#10;       ¬(∃c' · c' ∈ class_of[{p}] ∧&#10;               c' ≠ c ∧&#10;               c ∈ is_a[{c'}])&#10;    ⇒ (∃e · p ∈ individuation[{e}] ∧&#10;            e ↦ c ∈ signatureForClasses)"/>
    <org.eventb.core.variable name="varE" org.eventb.core.comment="les expressions encore à analyser pour la classe courante " org.eventb.core.identifier="expressionsLeftForCurrentClass"/>
</org.eventb.core.machineFile>
