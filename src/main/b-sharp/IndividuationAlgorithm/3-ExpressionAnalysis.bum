<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.configuration="org.eventb.core.fwd" version="5">
    <org.eventb.core.refinesMachine name="'" org.eventb.core.target="2-ExpressionTraversal"/>
    <org.eventb.core.seesContext name="(" org.eventb.core.target="110-MappingContext"/>
    <org.eventb.core.variable name="var2" org.eventb.core.comment="l'association d'une signature à une ou plusieurs classe" org.eventb.core.identifier="signatures"/>
    <org.eventb.core.variable name="var8" org.eventb.core.comment="la relation de sous-ensemble entre des signatures" org.eventb.core.identifier="subsets"/>
    <org.eventb.core.variable name="7" org.eventb.core.comment="les éléments qu'il reste à arrimer sur l'étage courant de l'arbre" org.eventb.core.identifier="currentLevel"/>
    <org.eventb.core.variable name="8" org.eventb.core.comment="la classe à arrimer" org.eventb.core.identifier="currentClass"/>
    <org.eventb.core.variable name=";" org.eventb.core.comment="le numéro de l'étage courant" org.eventb.core.identifier="levelNum"/>
    <org.eventb.core.variable name="?" org.eventb.core.comment="l'ensemble des classes arrimées" org.eventb.core.identifier="mapped"/>
    <org.eventb.core.variable name="F" org.eventb.core.comment="l'expression en cours d'évaluation" org.eventb.core.identifier="currentExpression"/>
    <org.eventb.core.variable name="var7" org.eventb.core.comment="les expressions qui permettent l'individuation de particuliers qui répondent aux axiomes de la classe courante" org.eventb.core.identifier="expressionsOfCurrentClass"/>
    <org.eventb.core.variable name="varE" org.eventb.core.comment="les expressions encore à analyser pour la classe courante " org.eventb.core.identifier="expressionsLeftForCurrentClass"/>
    <org.eventb.core.variable name="varG" org.eventb.core.comment="l'ensemble des expressions analysées" org.eventb.core.identifier="analysedExpressions"/>
    <org.eventb.core.event name="varH" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="INITIALISATION">
        <org.eventb.core.action name="'" org.eventb.core.assignment="definedSignatures ≔ ∅" org.eventb.core.comment="aucune signature n'est définie" org.eventb.core.label="init_definedSignatures"/>
        <org.eventb.core.action name="(" org.eventb.core.assignment="definedSubsets ≔ ∅" org.eventb.core.comment="aucune relation de sous-ensemble n'est définie" org.eventb.core.label="init_definedSubsets"/>
        <org.eventb.core.action name=")" org.eventb.core.assignment="currentExpressionAnalysed ≔ 0" org.eventb.core.comment="l'expression n'est pas analysée" org.eventb.core.label="init_currentExpressionAnalysed"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="varI" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="final">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="final"/>
        <org.eventb.core.action name="act1" org.eventb.core.assignment="signatures,subsets  ≔ definedSignatures, definedSubsets" org.eventb.core.comment="assignation des signatures et sous-ensembles définies aux signatures et sous-ensembles finaux " org.eventb.core.label="final"/>
        <org.eventb.core.guard name="'" org.eventb.core.comment="on a appliqué le procédé d'arrimage à toutes les classes" org.eventb.core.label="final_grd1" org.eventb.core.predicate="mapped = C"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="lorsque toutes les classes sont arrimées, on sait que toutes les expressions correspondant à des signatures valides ont étés analysées" org.eventb.core.label="final_grd2" org.eventb.core.predicate="∀c · c ∈ C&#10;  ⇒ (∀e · individuation[{e}]≠∅ ∧&#10;           (∀p · p ∈ individuation[{e}]&#10;              ⇔ c ∈ class_of[{p}])&#10;        ⇒ e ↦ c ∈ analysedExpressions)" org.eventb.core.theorem="true"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="varJ" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="next_class">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="next_class"/>
        <org.eventb.core.action name="(" org.eventb.core.assignment="currentExpressionAnalysed ≔ 0" org.eventb.core.label="nextClass_resetCurrentExpressionAnalysed"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="varK" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="next_level">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="next_level"/>
        <org.eventb.core.action name="(" org.eventb.core.assignment="currentExpressionAnalysed ≔ 0" org.eventb.core.label="nextLevel_resetCurrentExpressionAnalysed"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="varL" org.eventb.core.comment="on passe à la prochaine expression" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="next_expression">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="next_expression"/>
        <org.eventb.core.action name="act1" org.eventb.core.assignment="currentExpressionAnalysed ≔ 0" org.eventb.core.label="nextExpression_resetCurrentExpressionAnalysed"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="varM" org.eventb.core.comment="l'arrimage de la classe est terminé" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="class_mapped">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="class_mapped"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="varN" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="expression_analysed">
        <org.eventb.core.refinesEvent name="'" org.eventb.core.target="expression_analysed"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="l'analyse de l'expression courante est terminée" org.eventb.core.label="expressionAnalysed_grd4" org.eventb.core.predicate="currentExpressionAnalysed = 1"/>
    </org.eventb.core.event>
    <org.eventb.core.variable name="varO" org.eventb.core.comment="les signatures définies au cours du procédé" org.eventb.core.identifier="definedSignatures"/>
    <org.eventb.core.variable name="varP" org.eventb.core.comment="les relations de sous-ensembles entre signatures définies au cours du procédé" org.eventb.core.identifier="definedSubsets"/>
    <org.eventb.core.invariant name="varQ" org.eventb.core.label="type_definedSignatures" org.eventb.core.predicate="definedSignatures ∈ E ↔ C"/>
    <org.eventb.core.invariant name="varR" org.eventb.core.label="type_definedSubsets" org.eventb.core.predicate="definedSubsets ∈ E ↔ E"/>
    <org.eventb.core.invariant name="var\" org.eventb.core.comment="0 = à analysé ; 1 = analysé" org.eventb.core.label="type_currentExpressionAnalysed" org.eventb.core.predicate="currentExpressionAnalysed ∈ {0,1}"/>
    <org.eventb.core.invariant name="varS" org.eventb.core.comment="tout particulier qui répond aux axiomes d'une classe arrimée est au moins individualisé par une expression associée à ses classes terminales" org.eventb.core.label="inv_allMappedAndStrictClassesAreDefined" org.eventb.core.predicate="∀p,c · p ∈ P ∧&#10;       c ∈ class_of_strict[{p}] ∧&#10;       c ∈ mapped&#10;    ⇒ (∃e · p ∈ individuation[{e}] ∧&#10;             e ↦ c ∈ definedSignatures)"/>
    <org.eventb.core.invariant name="varT" org.eventb.core.comment="tout particulier individualisé par une signature associé à une classe c respectent les axiomes de la classe c" org.eventb.core.label="inv_allDefinedSignaturesAreValid" org.eventb.core.predicate="∀e,c · e ↦ c ∈ definedSignatures&#10;        ⇒ ( ∀p · p ∈ individuation[{e}]&#10;            ⇒ c ∈ class_of[{p}])"/>
    <org.eventb.core.invariant name="varU" org.eventb.core.comment="toute expression utilisée comme signature permet l'individuation d'au moins un particulier " org.eventb.core.label="inv_allDefinedSignaturesIndividuateAParticular" org.eventb.core.predicate="∀e · e ∈ dom(definedSignatures)&#10;  ⇒ individuation[{e}] ≠ ∅"/>
    <org.eventb.core.invariant name="varV" org.eventb.core.comment="la relation de sous-ensembles est définie à partir d'expression utilisées comme signature" org.eventb.core.label="inv_definedSubsetsDefinedOverDefinedSignatures" org.eventb.core.predicate="dom(definedSubsets) ⊆ dom(definedSignatures)"/>
    <org.eventb.core.invariant name="varW" org.eventb.core.comment="toutes signatures qui individues des particuliers en commun sont en relations subsets" org.eventb.core.label="inv_overlapingDefinedSignaturesAreLinkByDefinedSubsets" org.eventb.core.predicate="∀e1,e2 · e1 ∈ dom(definedSignatures) ∧ &#10;         e2 ∈ dom(definedSignatures) ∧&#10;         e1 ≠ e2 ∧&#10;         e1 ∈ exp_overlap[{e2}] &#10;      ⇒ (∃s,n · n ∈ ℕ1 ∧ &#10;                 s ∈ 0‥n → E ∧&#10;                 (∀i · i ∈ 0‥n−1 ⇒ s(i) ∈ definedSubsets[{s(i+1)}] ∨&#10;                                    s(i) ∈ definedSubsets∼[{s(i+1)}]) ∧&#10;                 s(0) = e1 ∧&#10;                 s(n) = e2)"/>
    <org.eventb.core.invariant name="varX" org.eventb.core.comment="les signatures notés comme étant en relation de sous-ensemble sont effectivement des sous-ensembles " org.eventb.core.label="inv_definedSubsetsAreEffectivelySubsets" org.eventb.core.predicate="∀sup,sub · sup ∈ definedSubsets[{sub}]&#10;        ⇒ sup ∈ exp_subsets[{sub}]"/>
    <org.eventb.core.invariant name="varY" org.eventb.core.comment="les clés des signatures notés comme étant en relation de sous-ensemble doivent être compatible" org.eventb.core.label="inv_definedSubsetsHaveCompatibleKeys" org.eventb.core.predicate="∀e1,e2 · e1 ∈ definedSubsets[{e2}]&#10;      ⇒ exp_key(e1) ∈ key_compatible[{exp_key(e2)}]"/>
    <org.eventb.core.invariant name="varZ" org.eventb.core.comment="il existe une expression pour faire l'individuation des particuliers dont la classe stricte est la classe courante&#10;cette expression est soit déjà définie comme une signature, est encore à analyser ou est en cours d'analyse" org.eventb.core.label="inv_allParticularOfStrictClassCurrentClassHasOrWillHaveASignature" org.eventb.core.predicate="∀e,c · e ↦ c ∈ analysedExpressions&#10;    ⇒ (∀p · p ∈ P ∧&#10;             p ∈ individuation[{e}] ∧&#10;             c ∈ class_of_strict[{p}]&#10;          ⇒ (∃e' · p ∈ individuation[{e'}] ∧&#10;                    ((c = currentClass ∧ &#10;                      e' ∈ expressionsLeftForCurrentClass) &#10;                     ∨&#10;                     (c = currentClass ∧ &#10;                      e' = currentExpression ∧ &#10;                      currentExpression ∈ expressionsOfCurrentClass ∧ &#10;                      currentExpression ↦ currentClass ∉ analysedExpressions)&#10;                     ∨ &#10;                      e' ↦ c ∈ definedSignatures)))"/>
    <org.eventb.core.variable name="var[" org.eventb.core.comment="l'analyse de l'expression courante est terminée" org.eventb.core.identifier="currentExpressionAnalysed"/>
    <org.eventb.core.invariant name="var]" org.eventb.core.comment="pour marquer l'expression courante comme analysée, il faut que les particuliers indivualisées par l'expression et dont la classe stricte &#10;est la classe courante soient individualisés par une expression marquée comme signature pour la classe ou par une expression encore à analyser" org.eventb.core.label="inv_currentExpressionAnalysedOnlyIfAllParticularOfStrictClassCurrentClassHasOrWillHaveASignature" org.eventb.core.predicate="currentExpressionAnalysed = 1&#10;⇒ currentExpression ∈ expressionsOfCurrentClass ∧&#10;   (∀p · p ∈ P ∧&#10;         p ∈ individuation[{currentExpression}] ∧&#10;         currentClass ∈ class_of_strict[{p}]&#10;      ⇒ (∃e · p ∈ individuation[{e}] ∧&#10;               (e ∈ expressionsLeftForCurrentClass &#10;                ∨&#10;                e ↦ currentClass ∈ definedSignatures)))"/>
    <org.eventb.core.event name="var^" org.eventb.core.comment="l'expression cournate n'est pas à ajouter obligatoirement aux signatures de la classe" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="analyse_not_required">
        <org.eventb.core.guard name="*" org.eventb.core.comment="l'expression courante est une expression valide pour une signature de la classe" org.eventb.core.label="analyseNotRequired_grd1" org.eventb.core.predicate="currentExpression ∈ expressionsOfCurrentClass"/>
        <org.eventb.core.guard name="'" org.eventb.core.comment="l'expression n'est pas analysée" org.eventb.core.label="analyseNotRequired_grd2" org.eventb.core.predicate="currentExpressionAnalysed = 0"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="les particuliers individualisés par l'expression sont déjà individualisés par une signature &#10;ou pourront l'être à l'aide d'une expression encore à analysée" org.eventb.core.label="analyseNotRequired_grd3" org.eventb.core.predicate="∀p · p ∈ P ∧&#10;     p ∈ individuation[{currentExpression}] ∧&#10;     currentClass ∈ class_of_strict[{p}]&#10;  ⇒ (∃e · p ∈ individuation[{e}] ∧&#10;           (e ∈ expressionsLeftForCurrentClass ∖ {currentExpression}&#10;            ∨&#10;            e ↦ currentClass ∈ definedSignatures))"/>
        <org.eventb.core.action name=")" org.eventb.core.assignment="currentExpressionAnalysed ≔ 1" org.eventb.core.comment="l'expression courante est marquée comme analysée" org.eventb.core.label="analyseNotRequired_setAnalysed"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="evt1" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="analyse_with_equivalent_signature">
        <org.eventb.core.guard name="*" org.eventb.core.comment="l'expression courante est une expression valide pour une signature de la classe" org.eventb.core.label="analyseWithEquivalentSignature_grd1" org.eventb.core.predicate="currentExpression∈expressionsOfCurrentClass"/>
        <org.eventb.core.guard name="'" org.eventb.core.comment="l'expression n'est pas analysée" org.eventb.core.label="analyseWithEquivalentSignature_grd2" org.eventb.core.predicate="currentExpressionAnalysed = 0"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="une expression équivalente a déjà été définie comme signature d'une autre classe" org.eventb.core.label="analyseWithEquivalentSignature_grd3" org.eventb.core.predicate="∃s,c · s ∈ exp_equivalent[{currentExpression}] ∧&#10;       c ≠ currentClass ∧&#10;       s ↦ c ∈ definedSignatures"/>
        <org.eventb.core.action name="," org.eventb.core.assignment="definedSignatures :∣ ∃equiv_signs, choice · equiv_signs = {s ∣ ∃c ·c ≠ currentClass ∧&#10;                                                                   s ∈ exp_equivalent[{currentExpression}] ∧&#10;                                                                   s ↦ c ∈ definedSignatures } ∧&#10;                                            choice ⊆ equiv_signs ∧&#10;                                            choice ≠ ∅ ∧&#10;                                            definedSignatures' = definedSignatures ∪ (choice × {currentClass})" org.eventb.core.comment="au moins une de ces signatures équivalentes est assignée comme signature pour la classe" org.eventb.core.label="analyseWithEquivalentSignature_addSToCurrentClass"/>
        <org.eventb.core.action name=")" org.eventb.core.assignment="currentExpressionAnalysed ≔ 1" org.eventb.core.comment="l'expression courante est marquée comme analysée" org.eventb.core.label="analyseWithEquivalentSignature_setAnalysed"/>
    </org.eventb.core.event>
    <org.eventb.core.event name="evt2" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="analyse_current_subsets_signature">
        <org.eventb.core.guard name="*" org.eventb.core.comment="l'expression courante est une expression valide pour une signature de la classe" org.eventb.core.label="analyseCurrentSubsetsSignature_grd1" org.eventb.core.predicate="currentExpression∈expressionsOfCurrentClass"/>
        <org.eventb.core.guard name="'" org.eventb.core.comment="l'expression n'est pas analysée" org.eventb.core.label="analyseCurrentSubsetsSignature_grd2" org.eventb.core.predicate="currentExpressionAnalysed = 0"/>
        <org.eventb.core.guard name="(" org.eventb.core.comment="une expression qui est un sous-ensemble de l'expression courante a déjà été définie comme signature d'une autre classe" org.eventb.core.label="analyseCurrentSubsetsSignature_grd3" org.eventb.core.predicate="∃s,c · s ∈ exp_subsets[{currentExpression}] ∧&#10;       s ↦ c ∈ definedSignatures"/>
        <org.eventb.core.action name="-" org.eventb.core.assignment="definedSignatures ≔ definedSignatures ∪ { currentExpression ↦ currentClass } " org.eventb.core.comment="l'expression est ajouté comme une signature pour la classe courante" org.eventb.core.label="analyseCurrentSubsetsSignature_addCurrentExpressionToSignatures"/>
        <org.eventb.core.action name="," org.eventb.core.assignment="definedSubsets ≔ definedSubsets ∪ ({ s ∣ ∃c · s ∈ exp_subsets[{currentExpression}] ∧&#10;                                              s ↦ c ∈ definedSignatures} × {currentExpression})" org.eventb.core.comment="toutes ses sous-ensembles sont ajoutés comme tel" org.eventb.core.label="analyseCurrentSubsetsSignature_updateSubsets"/>
        <org.eventb.core.action name=")" org.eventb.core.assignment="currentExpressionAnalysed ≔ 1" org.eventb.core.comment="l'expression courante est marquée comme analysée" org.eventb.core.label="analyseWithEquivalentSignatureNotDefined_setAnalysed"/>
    </org.eventb.core.event>
    <org.eventb.core.invariant name="var_" org.eventb.core.comment="Les conditions d'analyse couvrent toutes les conditions, donc il n'y a pas d'interblocage possible dans la phase d'analyse" org.eventb.core.label="dlf_analyse" org.eventb.core.predicate="⊤" org.eventb.core.theorem="true"/>
</org.eventb.core.machineFile>
